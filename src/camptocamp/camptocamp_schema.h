// -*- mode: c++ -*-
// This file was automatically generated by SqlOrm

/***************************************************************************************************
 *
 * $ALPINE_TOOLKIT_BEGIN_LICENSE:GPL3$
 *
 * Copyright (C) 2017 Fabrice Salvaire
 * Contact: http://www.fabrice-salvaire.fr
 *
 * This file is part of the QtCarto library.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * $ALPINE_TOOLKIT_END_LICENSE$
 *
 **************************************************************************************************/

/**************************************************************************************************/

#ifndef __CAMPTOCAMP_SCHEMA_H__
#define __CAMPTOCAMP_SCHEMA_H__

/**************************************************************************************************/

#define QT_SHAREDPOINTER_TRACK_POINTERS // For dubug purpose

#include "orm/database_row.h"
#include "orm/database_row_list.h"
#include "orm/database_schema.h"
#include "orm/schema.h"

#include <QAbstractListModel>
#include <QChar>
#include <QDataStream>
#include <QDate>
#include <QDateTime>
#include <QJsonObject>
#include <QMap>
#include <QSharedPointer>
#include <QSqlQuery>
#include <QSqlRecord>
#include <QString>
#include <QStringList>
#include <QtDebug>
#include <QVariant>
#include <QVariantList>

/**************************************************************************************************/

class AreaAssociations;
class AreaAssociationsPtr;

/**************************************************************************************************/

class AreaAssociationsSchema : public QcSchema
{
public:
  enum Fields {
    AREA_ID,
    DOCUMENT_ID
  };
  static const int NUMBER_OF_FIELDS = 2;

public:
  static AreaAssociationsSchema & instance()
  {
    static AreaAssociationsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  AreaAssociationsSchema(const AreaAssociationsSchema &) = delete;
  AreaAssociationsSchema(AreaAssociationsSchema &&) = delete;
  AreaAssociationsSchema & operator=(const AreaAssociationsSchema &) = delete;
  AreaAssociationsSchema & operator=(AreaAssociationsSchema &&) = delete;

protected:
  AreaAssociationsSchema();
  ~AreaAssociationsSchema();
};

/**************************************************************************************************/

class AreaAssociations : public QObject, public QcRow<AreaAssociationsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int area_id READ area_id WRITE set_area_id NOTIFY area_idChanged)
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)

public:
  typedef AreaAssociationsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class AreaAssociationsPtr;

public:
  AreaAssociations();
  AreaAssociations(const AreaAssociations & other);
  AreaAssociations(const QJsonObject & json_object); // JSON deserializer
  AreaAssociations(const QVariantHash & variant_hash);
  AreaAssociations(const QVariantList & variants);
  AreaAssociations(const QSqlRecord & record); // SQL deserializer
  AreaAssociations(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~AreaAssociations();

  AreaAssociations & operator=(const AreaAssociations & other);

  bool operator==(const AreaAssociations & other) const;

  // Getter/Setter

  int area_id() const { return m_area_id; }
  void set_area_id(int value);

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_area_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_area_id_modified() const { return bit_status(Schema::Fields::AREA_ID); }
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void area_idChanged();
  void document_idChanged();

private:
  int m_area_id;
  int m_document_id;

};

QDataStream & operator<<(QDataStream & out, const AreaAssociations & obj);
QDataStream & operator>>(QDataStream & in, AreaAssociations & obj);
// qRegisterMetaTypeStreamOperators<AreaAssociations>("AreaAssociations");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const AreaAssociations & obj);
#endif

/**************************************************************************************************/

class AreaAssociationsPtr
{
public:
  typedef AreaAssociations Class;

public:
  AreaAssociationsPtr() : m_ptr() {}
  AreaAssociationsPtr(const AreaAssociationsPtr & other) : m_ptr(other.m_ptr) {}
  ~AreaAssociationsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete AreaAssociationsPtr of" << *m_ptr;
    // qInfo() << "--- Delete AreaAssociationsPtr";
    // m_ptr.clear();
  }

  AreaAssociationsPtr & operator=(const AreaAssociationsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  AreaAssociationsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  AreaAssociationsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  AreaAssociationsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  AreaAssociationsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  AreaAssociationsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  AreaAssociationsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  AreaAssociationsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const AreaAssociationsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const AreaAssociationsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const AreaAssociationsPtr & obj);
#endif

/**************************************************************************************************/

class AreaAssociationsCache : public QObject
{
  Q_OBJECT

public:
  typedef AreaAssociations * t_Key;
  typedef AreaAssociationsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  AreaAssociationsCache();
  ~AreaAssociationsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class AreaAssociationsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef AreaAssociationsPtr Item;
  typedef QList<Item> ItemList;

public:
  AreaAssociationsModel();
  AreaAssociationsModel(const ItemList & items);
  ~AreaAssociationsModel();

  // Fixme: use AreaAssociationsSchema::Fields ???
  enum Roles {
    AREA_ID = Qt::UserRole + 1,
    DOCUMENT_ID
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class Areas;
class AreasPtr;

/**************************************************************************************************/

class AreasSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    AREA_TYPE
  };
  static const int NUMBER_OF_FIELDS = 2;

public:
  static AreasSchema & instance()
  {
    static AreasSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  AreasSchema(const AreasSchema &) = delete;
  AreasSchema(AreasSchema &&) = delete;
  AreasSchema & operator=(const AreasSchema &) = delete;
  AreasSchema & operator=(AreasSchema &&) = delete;

protected:
  AreasSchema();
  ~AreasSchema();
};

/**************************************************************************************************/

class Areas : public QObject, public QcRow<AreasSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QString area_type READ area_type WRITE set_area_type NOTIFY area_typeChanged)

public:
  typedef AreasPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class AreasPtr;

public:
  Areas();
  Areas(const Areas & other);
  Areas(const QJsonObject & json_object); // JSON deserializer
  Areas(const QVariantHash & variant_hash);
  Areas(const QVariantList & variants);
  Areas(const QSqlRecord & record); // SQL deserializer
  Areas(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Areas();

  Areas & operator=(const Areas & other);

  bool operator==(const Areas & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QString & area_type() const { return m_area_type; }
  void set_area_type(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_area_type_modified() const { return bit_status(Schema::Fields::AREA_TYPE); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void area_typeChanged();

private:
  int m_document_id;
  QString m_area_type;

};

QDataStream & operator<<(QDataStream & out, const Areas & obj);
QDataStream & operator>>(QDataStream & in, Areas & obj);
// qRegisterMetaTypeStreamOperators<Areas>("Areas");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Areas & obj);
#endif

/**************************************************************************************************/

class AreasPtr
{
public:
  typedef Areas Class;

public:
  AreasPtr() : m_ptr() {}
  AreasPtr(const AreasPtr & other) : m_ptr(other.m_ptr) {}
  ~AreasPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete AreasPtr of" << *m_ptr;
    // qInfo() << "--- Delete AreasPtr";
    // m_ptr.clear();
  }

  AreasPtr & operator=(const AreasPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  AreasPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  AreasPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  AreasPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  AreasPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  AreasPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  AreasPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  AreasPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const AreasPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const AreasPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const AreasPtr & obj);
#endif

/**************************************************************************************************/

class AreasCache : public QObject
{
  Q_OBJECT

public:
  typedef Areas * t_Key;
  typedef AreasPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  AreasCache();
  ~AreasCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class AreasModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef AreasPtr Item;
  typedef QList<Item> ItemList;

public:
  AreasModel();
  AreasModel(const ItemList & items);
  ~AreasModel();

  // Fixme: use AreasSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    AREA_TYPE
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class Articles;
class ArticlesPtr;

/**************************************************************************************************/

class ArticlesSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACTIVITIES,
    ARTICLE_TYPE,
    CATEGORIES
  };
  static const int NUMBER_OF_FIELDS = 4;

public:
  static ArticlesSchema & instance()
  {
    static ArticlesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  ArticlesSchema(const ArticlesSchema &) = delete;
  ArticlesSchema(ArticlesSchema &&) = delete;
  ArticlesSchema & operator=(const ArticlesSchema &) = delete;
  ArticlesSchema & operator=(ArticlesSchema &&) = delete;

protected:
  ArticlesSchema();
  ~ArticlesSchema();
};

/**************************************************************************************************/

class Articles : public QObject, public QcRow<ArticlesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QString article_type READ article_type WRITE set_article_type NOTIFY article_typeChanged)
  Q_PROPERTY(QStringList categories READ categories WRITE set_categories NOTIFY categoriesChanged)

public:
  typedef ArticlesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class ArticlesPtr;

public:
  Articles();
  Articles(const Articles & other);
  Articles(const QJsonObject & json_object); // JSON deserializer
  Articles(const QVariantHash & variant_hash);
  Articles(const QVariantList & variants);
  Articles(const QSqlRecord & record); // SQL deserializer
  Articles(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Articles();

  Articles & operator=(const Articles & other);

  bool operator==(const Articles & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QString & article_type() const { return m_article_type; }
  void set_article_type(const QString & value);

  const QStringList & categories() const { return m_categories; }
  void set_categories(const QStringList & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_article_type_modified() const { return bit_status(Schema::Fields::ARTICLE_TYPE); }
  bool is_categories_modified() const { return bit_status(Schema::Fields::CATEGORIES); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void activitiesChanged();
  void article_typeChanged();
  void categoriesChanged();

private:
  int m_document_id;
  QStringList m_activities;
  QString m_article_type;
  QStringList m_categories;

};

QDataStream & operator<<(QDataStream & out, const Articles & obj);
QDataStream & operator>>(QDataStream & in, Articles & obj);
// qRegisterMetaTypeStreamOperators<Articles>("Articles");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Articles & obj);
#endif

/**************************************************************************************************/

class ArticlesPtr
{
public:
  typedef Articles Class;

public:
  ArticlesPtr() : m_ptr() {}
  ArticlesPtr(const ArticlesPtr & other) : m_ptr(other.m_ptr) {}
  ~ArticlesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete ArticlesPtr of" << *m_ptr;
    // qInfo() << "--- Delete ArticlesPtr";
    // m_ptr.clear();
  }

  ArticlesPtr & operator=(const ArticlesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  ArticlesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  ArticlesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  ArticlesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  ArticlesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  ArticlesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  ArticlesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  ArticlesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const ArticlesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const ArticlesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const ArticlesPtr & obj);
#endif

/**************************************************************************************************/

class ArticlesCache : public QObject
{
  Q_OBJECT

public:
  typedef Articles * t_Key;
  typedef ArticlesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  ArticlesCache();
  ~ArticlesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class ArticlesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef ArticlesPtr Item;
  typedef QList<Item> ItemList;

public:
  ArticlesModel();
  ArticlesModel(const ItemList & items);
  ~ArticlesModel();

  // Fixme: use ArticlesSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACTIVITIES,
    ARTICLE_TYPE,
    CATEGORIES
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class Associations;
class AssociationsPtr;

/**************************************************************************************************/

class AssociationsSchema : public QcSchema
{
public:
  enum Fields {
    CHILD_DOCUMENT_ID,
    PARENT_DOCUMENT_ID,
    CHILD_DOCUMENT_TYPE,
    PARENT_DOCUMENT_TYPE
  };
  static const int NUMBER_OF_FIELDS = 4;

public:
  static AssociationsSchema & instance()
  {
    static AssociationsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  AssociationsSchema(const AssociationsSchema &) = delete;
  AssociationsSchema(AssociationsSchema &&) = delete;
  AssociationsSchema & operator=(const AssociationsSchema &) = delete;
  AssociationsSchema & operator=(AssociationsSchema &&) = delete;

protected:
  AssociationsSchema();
  ~AssociationsSchema();
};

/**************************************************************************************************/

class Associations : public QObject, public QcRow<AssociationsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int child_document_id READ child_document_id WRITE set_child_document_id NOTIFY child_document_idChanged)
  Q_PROPERTY(int parent_document_id READ parent_document_id WRITE set_parent_document_id NOTIFY parent_document_idChanged)
  Q_PROPERTY(QChar child_document_type READ child_document_type WRITE set_child_document_type NOTIFY child_document_typeChanged)
  Q_PROPERTY(QChar parent_document_type READ parent_document_type WRITE set_parent_document_type NOTIFY parent_document_typeChanged)

public:
  typedef AssociationsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class AssociationsPtr;

public:
  Associations();
  Associations(const Associations & other);
  Associations(const QJsonObject & json_object); // JSON deserializer
  Associations(const QVariantHash & variant_hash);
  Associations(const QVariantList & variants);
  Associations(const QSqlRecord & record); // SQL deserializer
  Associations(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Associations();

  Associations & operator=(const Associations & other);

  bool operator==(const Associations & other) const;

  // Getter/Setter

  int child_document_id() const { return m_child_document_id; }
  void set_child_document_id(int value);

  int parent_document_id() const { return m_parent_document_id; }
  void set_parent_document_id(int value);

  const QChar & child_document_type() const { return m_child_document_type; }
  void set_child_document_type(const QChar & value);

  const QChar & parent_document_type() const { return m_parent_document_type; }
  void set_parent_document_type(const QChar & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_child_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_child_document_id_modified() const { return bit_status(Schema::Fields::CHILD_DOCUMENT_ID); }
  bool is_parent_document_id_modified() const { return bit_status(Schema::Fields::PARENT_DOCUMENT_ID); }
  bool is_child_document_type_modified() const { return bit_status(Schema::Fields::CHILD_DOCUMENT_TYPE); }
  bool is_parent_document_type_modified() const { return bit_status(Schema::Fields::PARENT_DOCUMENT_TYPE); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void child_document_idChanged();
  void parent_document_idChanged();
  void child_document_typeChanged();
  void parent_document_typeChanged();

private:
  int m_child_document_id;
  int m_parent_document_id;
  QChar m_child_document_type;
  QChar m_parent_document_type;

};

QDataStream & operator<<(QDataStream & out, const Associations & obj);
QDataStream & operator>>(QDataStream & in, Associations & obj);
// qRegisterMetaTypeStreamOperators<Associations>("Associations");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Associations & obj);
#endif

/**************************************************************************************************/

class AssociationsPtr
{
public:
  typedef Associations Class;

public:
  AssociationsPtr() : m_ptr() {}
  AssociationsPtr(const AssociationsPtr & other) : m_ptr(other.m_ptr) {}
  ~AssociationsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete AssociationsPtr of" << *m_ptr;
    // qInfo() << "--- Delete AssociationsPtr";
    // m_ptr.clear();
  }

  AssociationsPtr & operator=(const AssociationsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  AssociationsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  AssociationsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  AssociationsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  AssociationsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  AssociationsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  AssociationsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  AssociationsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const AssociationsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const AssociationsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const AssociationsPtr & obj);
#endif

/**************************************************************************************************/

class AssociationsCache : public QObject
{
  Q_OBJECT

public:
  typedef Associations * t_Key;
  typedef AssociationsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  AssociationsCache();
  ~AssociationsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class AssociationsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef AssociationsPtr Item;
  typedef QList<Item> ItemList;

public:
  AssociationsModel();
  AssociationsModel(const ItemList & items);
  ~AssociationsModel();

  // Fixme: use AssociationsSchema::Fields ???
  enum Roles {
    CHILD_DOCUMENT_ID = Qt::UserRole + 1,
    PARENT_DOCUMENT_ID,
    CHILD_DOCUMENT_TYPE,
    PARENT_DOCUMENT_TYPE
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class Books;
class BooksPtr;

/**************************************************************************************************/

class BooksSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACTIVITIES,
    AUTHOR,
    BOOK_TYPES,
    EDITOR,
    ISBN,
    LANGS,
    NB_PAGES,
    PUBLICATION_DATE,
    URL
  };
  static const int NUMBER_OF_FIELDS = 10;

public:
  static BooksSchema & instance()
  {
    static BooksSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  BooksSchema(const BooksSchema &) = delete;
  BooksSchema(BooksSchema &&) = delete;
  BooksSchema & operator=(const BooksSchema &) = delete;
  BooksSchema & operator=(BooksSchema &&) = delete;

protected:
  BooksSchema();
  ~BooksSchema();
};

/**************************************************************************************************/

class Books : public QObject, public QcRow<BooksSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QString author READ author WRITE set_author NOTIFY authorChanged)
  Q_PROPERTY(QStringList book_types READ book_types WRITE set_book_types NOTIFY book_typesChanged)
  Q_PROPERTY(QString editor READ editor WRITE set_editor NOTIFY editorChanged)
  Q_PROPERTY(QString isbn READ isbn WRITE set_isbn NOTIFY isbnChanged)
  Q_PROPERTY(QStringList langs READ langs WRITE set_langs NOTIFY langsChanged)
  Q_PROPERTY(int nb_pages READ nb_pages WRITE set_nb_pages NOTIFY nb_pagesChanged)
  Q_PROPERTY(QString publication_date READ publication_date WRITE set_publication_date NOTIFY publication_dateChanged)
  Q_PROPERTY(QString url READ url WRITE set_url NOTIFY urlChanged)

public:
  typedef BooksPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class BooksPtr;

public:
  Books();
  Books(const Books & other);
  Books(const QJsonObject & json_object); // JSON deserializer
  Books(const QVariantHash & variant_hash);
  Books(const QVariantList & variants);
  Books(const QSqlRecord & record); // SQL deserializer
  Books(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Books();

  Books & operator=(const Books & other);

  bool operator==(const Books & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QString & author() const { return m_author; }
  void set_author(const QString & value);

  const QStringList & book_types() const { return m_book_types; }
  void set_book_types(const QStringList & value);

  const QString & editor() const { return m_editor; }
  void set_editor(const QString & value);

  const QString & isbn() const { return m_isbn; }
  void set_isbn(const QString & value);

  const QStringList & langs() const { return m_langs; }
  void set_langs(const QStringList & value);

  int nb_pages() const { return m_nb_pages; }
  void set_nb_pages(int value);

  const QString & publication_date() const { return m_publication_date; }
  void set_publication_date(const QString & value);

  const QString & url() const { return m_url; }
  void set_url(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_author_modified() const { return bit_status(Schema::Fields::AUTHOR); }
  bool is_book_types_modified() const { return bit_status(Schema::Fields::BOOK_TYPES); }
  bool is_editor_modified() const { return bit_status(Schema::Fields::EDITOR); }
  bool is_isbn_modified() const { return bit_status(Schema::Fields::ISBN); }
  bool is_langs_modified() const { return bit_status(Schema::Fields::LANGS); }
  bool is_nb_pages_modified() const { return bit_status(Schema::Fields::NB_PAGES); }
  bool is_publication_date_modified() const { return bit_status(Schema::Fields::PUBLICATION_DATE); }
  bool is_url_modified() const { return bit_status(Schema::Fields::URL); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void activitiesChanged();
  void authorChanged();
  void book_typesChanged();
  void editorChanged();
  void isbnChanged();
  void langsChanged();
  void nb_pagesChanged();
  void publication_dateChanged();
  void urlChanged();

private:
  int m_document_id;
  QStringList m_activities;
  QString m_author;
  QStringList m_book_types;
  QString m_editor;
  QString m_isbn;
  QStringList m_langs;
  int m_nb_pages;
  QString m_publication_date;
  QString m_url;

};

QDataStream & operator<<(QDataStream & out, const Books & obj);
QDataStream & operator>>(QDataStream & in, Books & obj);
// qRegisterMetaTypeStreamOperators<Books>("Books");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Books & obj);
#endif

/**************************************************************************************************/

class BooksPtr
{
public:
  typedef Books Class;

public:
  BooksPtr() : m_ptr() {}
  BooksPtr(const BooksPtr & other) : m_ptr(other.m_ptr) {}
  ~BooksPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete BooksPtr of" << *m_ptr;
    // qInfo() << "--- Delete BooksPtr";
    // m_ptr.clear();
  }

  BooksPtr & operator=(const BooksPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  BooksPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  BooksPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  BooksPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  BooksPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  BooksPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  BooksPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  BooksPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const BooksPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const BooksPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const BooksPtr & obj);
#endif

/**************************************************************************************************/

class BooksCache : public QObject
{
  Q_OBJECT

public:
  typedef Books * t_Key;
  typedef BooksPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  BooksCache();
  ~BooksCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class BooksModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef BooksPtr Item;
  typedef QList<Item> ItemList;

public:
  BooksModel();
  BooksModel(const ItemList & items);
  ~BooksModel();

  // Fixme: use BooksSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACTIVITIES,
    AUTHOR,
    BOOK_TYPES,
    EDITOR,
    ISBN,
    LANGS,
    NB_PAGES,
    PUBLICATION_DATE,
    URL
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class Documents;
class DocumentsPtr;

/**************************************************************************************************/

class DocumentsSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    PROTECTED_FLAG,
    QUALITY,
    REDIRECTS_TO,
    TYPE,
    VERSION
  };
  static const int NUMBER_OF_FIELDS = 6;

public:
  static DocumentsSchema & instance()
  {
    static DocumentsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  DocumentsSchema(const DocumentsSchema &) = delete;
  DocumentsSchema(DocumentsSchema &&) = delete;
  DocumentsSchema & operator=(const DocumentsSchema &) = delete;
  DocumentsSchema & operator=(DocumentsSchema &&) = delete;

protected:
  DocumentsSchema();
  ~DocumentsSchema();
};

/**************************************************************************************************/

class Documents : public QObject, public QcRow<DocumentsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(bool protected_flag READ protected_flag WRITE set_protected_flag NOTIFY protected_flagChanged)
  Q_PROPERTY(QString quality READ quality WRITE set_quality NOTIFY qualityChanged)
  Q_PROPERTY(int redirects_to READ redirects_to WRITE set_redirects_to NOTIFY redirects_toChanged)
  Q_PROPERTY(QChar type READ type WRITE set_type NOTIFY typeChanged)
  Q_PROPERTY(int version READ version WRITE set_version NOTIFY versionChanged)

public:
  typedef DocumentsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class DocumentsPtr;

public:
  Documents();
  Documents(const Documents & other);
  Documents(const QJsonObject & json_object); // JSON deserializer
  Documents(const QVariantHash & variant_hash);
  Documents(const QVariantList & variants);
  Documents(const QSqlRecord & record); // SQL deserializer
  Documents(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Documents();

  Documents & operator=(const Documents & other);

  bool operator==(const Documents & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  bool protected_flag() const { return m_protected_flag; }
  void set_protected_flag(bool value);

  const QString & quality() const { return m_quality; }
  void set_quality(const QString & value);

  int redirects_to() const { return m_redirects_to; }
  void set_redirects_to(int value);

  const QChar & type() const { return m_type; }
  void set_type(const QChar & value);

  int version() const { return m_version; }
  void set_version(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_protected_flag_modified() const { return bit_status(Schema::Fields::PROTECTED_FLAG); }
  bool is_quality_modified() const { return bit_status(Schema::Fields::QUALITY); }
  bool is_redirects_to_modified() const { return bit_status(Schema::Fields::REDIRECTS_TO); }
  bool is_type_modified() const { return bit_status(Schema::Fields::TYPE); }
  bool is_version_modified() const { return bit_status(Schema::Fields::VERSION); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void protected_flagChanged();
  void qualityChanged();
  void redirects_toChanged();
  void typeChanged();
  void versionChanged();

private:
  int m_document_id;
  bool m_protected_flag;
  QString m_quality;
  int m_redirects_to;
  QChar m_type;
  int m_version;

};

QDataStream & operator<<(QDataStream & out, const Documents & obj);
QDataStream & operator>>(QDataStream & in, Documents & obj);
// qRegisterMetaTypeStreamOperators<Documents>("Documents");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Documents & obj);
#endif

/**************************************************************************************************/

class DocumentsPtr
{
public:
  typedef Documents Class;

public:
  DocumentsPtr() : m_ptr() {}
  DocumentsPtr(const DocumentsPtr & other) : m_ptr(other.m_ptr) {}
  ~DocumentsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete DocumentsPtr of" << *m_ptr;
    // qInfo() << "--- Delete DocumentsPtr";
    // m_ptr.clear();
  }

  DocumentsPtr & operator=(const DocumentsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  DocumentsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  DocumentsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  DocumentsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  DocumentsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  DocumentsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  DocumentsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  DocumentsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const DocumentsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const DocumentsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const DocumentsPtr & obj);
#endif

/**************************************************************************************************/

class DocumentsCache : public QObject
{
  Q_OBJECT

public:
  typedef Documents * t_Key;
  typedef DocumentsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  DocumentsCache();
  ~DocumentsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class DocumentsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef DocumentsPtr Item;
  typedef QList<Item> ItemList;

public:
  DocumentsModel();
  DocumentsModel(const ItemList & items);
  ~DocumentsModel();

  // Fixme: use DocumentsSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    PROTECTED_FLAG,
    QUALITY,
    REDIRECTS_TO,
    TYPE,
    VERSION
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class DocumentsGeometries;
class DocumentsGeometriesPtr;

/**************************************************************************************************/

class DocumentsGeometriesSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    GEOM,
    GEOM_DETAIL,
    VERSION
  };
  static const int NUMBER_OF_FIELDS = 4;

public:
  static DocumentsGeometriesSchema & instance()
  {
    static DocumentsGeometriesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  DocumentsGeometriesSchema(const DocumentsGeometriesSchema &) = delete;
  DocumentsGeometriesSchema(DocumentsGeometriesSchema &&) = delete;
  DocumentsGeometriesSchema & operator=(const DocumentsGeometriesSchema &) = delete;
  DocumentsGeometriesSchema & operator=(DocumentsGeometriesSchema &&) = delete;

protected:
  DocumentsGeometriesSchema();
  ~DocumentsGeometriesSchema();
};

/**************************************************************************************************/

class DocumentsGeometries : public QObject, public QcRow<DocumentsGeometriesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QString geom READ geom WRITE set_geom NOTIFY geomChanged)
  Q_PROPERTY(QString geom_detail READ geom_detail WRITE set_geom_detail NOTIFY geom_detailChanged)
  Q_PROPERTY(int version READ version WRITE set_version NOTIFY versionChanged)

public:
  typedef DocumentsGeometriesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class DocumentsGeometriesPtr;

public:
  DocumentsGeometries();
  DocumentsGeometries(const DocumentsGeometries & other);
  DocumentsGeometries(const QJsonObject & json_object); // JSON deserializer
  DocumentsGeometries(const QVariantHash & variant_hash);
  DocumentsGeometries(const QVariantList & variants);
  DocumentsGeometries(const QSqlRecord & record); // SQL deserializer
  DocumentsGeometries(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~DocumentsGeometries();

  DocumentsGeometries & operator=(const DocumentsGeometries & other);

  bool operator==(const DocumentsGeometries & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QString & geom() const { return m_geom; }
  void set_geom(const QString & value);

  const QString & geom_detail() const { return m_geom_detail; }
  void set_geom_detail(const QString & value);

  int version() const { return m_version; }
  void set_version(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_geom_modified() const { return bit_status(Schema::Fields::GEOM); }
  bool is_geom_detail_modified() const { return bit_status(Schema::Fields::GEOM_DETAIL); }
  bool is_version_modified() const { return bit_status(Schema::Fields::VERSION); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void geomChanged();
  void geom_detailChanged();
  void versionChanged();

private:
  int m_document_id;
  QString m_geom;
  QString m_geom_detail;
  int m_version;

};

QDataStream & operator<<(QDataStream & out, const DocumentsGeometries & obj);
QDataStream & operator>>(QDataStream & in, DocumentsGeometries & obj);
// qRegisterMetaTypeStreamOperators<DocumentsGeometries>("DocumentsGeometries");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const DocumentsGeometries & obj);
#endif

/**************************************************************************************************/

class DocumentsGeometriesPtr
{
public:
  typedef DocumentsGeometries Class;

public:
  DocumentsGeometriesPtr() : m_ptr() {}
  DocumentsGeometriesPtr(const DocumentsGeometriesPtr & other) : m_ptr(other.m_ptr) {}
  ~DocumentsGeometriesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete DocumentsGeometriesPtr of" << *m_ptr;
    // qInfo() << "--- Delete DocumentsGeometriesPtr";
    // m_ptr.clear();
  }

  DocumentsGeometriesPtr & operator=(const DocumentsGeometriesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  DocumentsGeometriesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  DocumentsGeometriesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  DocumentsGeometriesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  DocumentsGeometriesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  DocumentsGeometriesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  DocumentsGeometriesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  DocumentsGeometriesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const DocumentsGeometriesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const DocumentsGeometriesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const DocumentsGeometriesPtr & obj);
#endif

/**************************************************************************************************/

class DocumentsGeometriesCache : public QObject
{
  Q_OBJECT

public:
  typedef DocumentsGeometries * t_Key;
  typedef DocumentsGeometriesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  DocumentsGeometriesCache();
  ~DocumentsGeometriesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class DocumentsGeometriesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef DocumentsGeometriesPtr Item;
  typedef QList<Item> ItemList;

public:
  DocumentsGeometriesModel();
  DocumentsGeometriesModel(const ItemList & items);
  ~DocumentsGeometriesModel();

  // Fixme: use DocumentsGeometriesSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    GEOM,
    GEOM_DETAIL,
    VERSION
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class DocumentsLocales;
class DocumentsLocalesPtr;

/**************************************************************************************************/

class DocumentsLocalesSchema : public QcSchema
{
public:
  enum Fields {
    ID,
    DESCRIPTION,
    DOCUMENT_ID,
    LANG,
    SUMMARY,
    TITLE,
    TYPE,
    VERSION
  };
  static const int NUMBER_OF_FIELDS = 8;

public:
  static DocumentsLocalesSchema & instance()
  {
    static DocumentsLocalesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  DocumentsLocalesSchema(const DocumentsLocalesSchema &) = delete;
  DocumentsLocalesSchema(DocumentsLocalesSchema &&) = delete;
  DocumentsLocalesSchema & operator=(const DocumentsLocalesSchema &) = delete;
  DocumentsLocalesSchema & operator=(DocumentsLocalesSchema &&) = delete;

protected:
  DocumentsLocalesSchema();
  ~DocumentsLocalesSchema();
};

/**************************************************************************************************/

class DocumentsLocales : public QObject, public QcRow<DocumentsLocalesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QString description READ description WRITE set_description NOTIFY descriptionChanged)
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QString lang READ lang WRITE set_lang NOTIFY langChanged)
  Q_PROPERTY(QString summary READ summary WRITE set_summary NOTIFY summaryChanged)
  Q_PROPERTY(QString title READ title WRITE set_title NOTIFY titleChanged)
  Q_PROPERTY(QChar type READ type WRITE set_type NOTIFY typeChanged)
  Q_PROPERTY(int version READ version WRITE set_version NOTIFY versionChanged)

public:
  typedef DocumentsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class DocumentsLocalesPtr;

public:
  DocumentsLocales();
  DocumentsLocales(const DocumentsLocales & other);
  DocumentsLocales(const QJsonObject & json_object); // JSON deserializer
  DocumentsLocales(const QVariantHash & variant_hash);
  DocumentsLocales(const QVariantList & variants);
  DocumentsLocales(const QSqlRecord & record); // SQL deserializer
  DocumentsLocales(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~DocumentsLocales();

  DocumentsLocales & operator=(const DocumentsLocales & other);

  bool operator==(const DocumentsLocales & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QString & description() const { return m_description; }
  void set_description(const QString & value);

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QString & lang() const { return m_lang; }
  void set_lang(const QString & value);

  const QString & summary() const { return m_summary; }
  void set_summary(const QString & value);

  const QString & title() const { return m_title; }
  void set_title(const QString & value);

  const QChar & type() const { return m_type; }
  void set_type(const QChar & value);

  int version() const { return m_version; }
  void set_version(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_description_modified() const { return bit_status(Schema::Fields::DESCRIPTION); }
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_lang_modified() const { return bit_status(Schema::Fields::LANG); }
  bool is_summary_modified() const { return bit_status(Schema::Fields::SUMMARY); }
  bool is_title_modified() const { return bit_status(Schema::Fields::TITLE); }
  bool is_type_modified() const { return bit_status(Schema::Fields::TYPE); }
  bool is_version_modified() const { return bit_status(Schema::Fields::VERSION); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void descriptionChanged();
  void document_idChanged();
  void langChanged();
  void summaryChanged();
  void titleChanged();
  void typeChanged();
  void versionChanged();

private:
  int m_id;
  QString m_description;
  int m_document_id;
  QString m_lang;
  QString m_summary;
  QString m_title;
  QChar m_type;
  int m_version;

};

QDataStream & operator<<(QDataStream & out, const DocumentsLocales & obj);
QDataStream & operator>>(QDataStream & in, DocumentsLocales & obj);
// qRegisterMetaTypeStreamOperators<DocumentsLocales>("DocumentsLocales");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const DocumentsLocales & obj);
#endif

/**************************************************************************************************/

class DocumentsLocalesPtr
{
public:
  typedef DocumentsLocales Class;

public:
  DocumentsLocalesPtr() : m_ptr() {}
  DocumentsLocalesPtr(const DocumentsLocalesPtr & other) : m_ptr(other.m_ptr) {}
  ~DocumentsLocalesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete DocumentsLocalesPtr of" << *m_ptr;
    // qInfo() << "--- Delete DocumentsLocalesPtr";
    // m_ptr.clear();
  }

  DocumentsLocalesPtr & operator=(const DocumentsLocalesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  DocumentsLocalesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  DocumentsLocalesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  DocumentsLocalesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  DocumentsLocalesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  DocumentsLocalesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  DocumentsLocalesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  DocumentsLocalesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const DocumentsLocalesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const DocumentsLocalesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const DocumentsLocalesPtr & obj);
#endif

/**************************************************************************************************/

class DocumentsLocalesCache : public QObject
{
  Q_OBJECT

public:
  typedef DocumentsLocales * t_Key;
  typedef DocumentsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  DocumentsLocalesCache();
  ~DocumentsLocalesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class DocumentsLocalesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef DocumentsLocalesPtr Item;
  typedef QList<Item> ItemList;

public:
  DocumentsLocalesModel();
  DocumentsLocalesModel(const ItemList & items);
  ~DocumentsLocalesModel();

  // Fixme: use DocumentsLocalesSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    DESCRIPTION,
    DOCUMENT_ID,
    LANG,
    SUMMARY,
    TITLE,
    TYPE,
    VERSION
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class DocumentsTopics;
class DocumentsTopicsPtr;

/**************************************************************************************************/

class DocumentsTopicsSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_LOCALE_ID,
    TOPIC_ID
  };
  static const int NUMBER_OF_FIELDS = 2;

public:
  static DocumentsTopicsSchema & instance()
  {
    static DocumentsTopicsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  DocumentsTopicsSchema(const DocumentsTopicsSchema &) = delete;
  DocumentsTopicsSchema(DocumentsTopicsSchema &&) = delete;
  DocumentsTopicsSchema & operator=(const DocumentsTopicsSchema &) = delete;
  DocumentsTopicsSchema & operator=(DocumentsTopicsSchema &&) = delete;

protected:
  DocumentsTopicsSchema();
  ~DocumentsTopicsSchema();
};

/**************************************************************************************************/

class DocumentsTopics : public QObject, public QcRow<DocumentsTopicsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_locale_id READ document_locale_id WRITE set_document_locale_id NOTIFY document_locale_idChanged)
  Q_PROPERTY(int topic_id READ topic_id WRITE set_topic_id NOTIFY topic_idChanged)

public:
  typedef DocumentsTopicsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class DocumentsTopicsPtr;

public:
  DocumentsTopics();
  DocumentsTopics(const DocumentsTopics & other);
  DocumentsTopics(const QJsonObject & json_object); // JSON deserializer
  DocumentsTopics(const QVariantHash & variant_hash);
  DocumentsTopics(const QVariantList & variants);
  DocumentsTopics(const QSqlRecord & record); // SQL deserializer
  DocumentsTopics(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~DocumentsTopics();

  DocumentsTopics & operator=(const DocumentsTopics & other);

  bool operator==(const DocumentsTopics & other) const;

  // Getter/Setter

  int document_locale_id() const { return m_document_locale_id; }
  void set_document_locale_id(int value);

  int topic_id() const { return m_topic_id; }
  void set_topic_id(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_locale_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_locale_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_LOCALE_ID); }
  bool is_topic_id_modified() const { return bit_status(Schema::Fields::TOPIC_ID); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_locale_idChanged();
  void topic_idChanged();

private:
  int m_document_locale_id;
  int m_topic_id;

};

QDataStream & operator<<(QDataStream & out, const DocumentsTopics & obj);
QDataStream & operator>>(QDataStream & in, DocumentsTopics & obj);
// qRegisterMetaTypeStreamOperators<DocumentsTopics>("DocumentsTopics");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const DocumentsTopics & obj);
#endif

/**************************************************************************************************/

class DocumentsTopicsPtr
{
public:
  typedef DocumentsTopics Class;

public:
  DocumentsTopicsPtr() : m_ptr() {}
  DocumentsTopicsPtr(const DocumentsTopicsPtr & other) : m_ptr(other.m_ptr) {}
  ~DocumentsTopicsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete DocumentsTopicsPtr of" << *m_ptr;
    // qInfo() << "--- Delete DocumentsTopicsPtr";
    // m_ptr.clear();
  }

  DocumentsTopicsPtr & operator=(const DocumentsTopicsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  DocumentsTopicsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  DocumentsTopicsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  DocumentsTopicsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  DocumentsTopicsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  DocumentsTopicsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  DocumentsTopicsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  DocumentsTopicsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const DocumentsTopicsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const DocumentsTopicsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const DocumentsTopicsPtr & obj);
#endif

/**************************************************************************************************/

class DocumentsTopicsCache : public QObject
{
  Q_OBJECT

public:
  typedef DocumentsTopics * t_Key;
  typedef DocumentsTopicsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  DocumentsTopicsCache();
  ~DocumentsTopicsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class DocumentsTopicsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef DocumentsTopicsPtr Item;
  typedef QList<Item> ItemList;

public:
  DocumentsTopicsModel();
  DocumentsTopicsModel(const ItemList & items);
  ~DocumentsTopicsModel();

  // Fixme: use DocumentsTopicsSchema::Fields ???
  enum Roles {
    DOCUMENT_LOCALE_ID = Qt::UserRole + 1,
    TOPIC_ID
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class DocumentsVersions;
class DocumentsVersionsPtr;

/**************************************************************************************************/

class DocumentsVersionsSchema : public QcSchema
{
public:
  enum Fields {
    ID,
    DOCUMENT_ARCHIVE_ID,
    DOCUMENT_GEOMETRY_ARCHIVE_ID,
    DOCUMENT_ID,
    DOCUMENT_LOCALES_ARCHIVE_ID,
    HISTORY_METADATA_ID,
    LANG
  };
  static const int NUMBER_OF_FIELDS = 7;

public:
  static DocumentsVersionsSchema & instance()
  {
    static DocumentsVersionsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  DocumentsVersionsSchema(const DocumentsVersionsSchema &) = delete;
  DocumentsVersionsSchema(DocumentsVersionsSchema &&) = delete;
  DocumentsVersionsSchema & operator=(const DocumentsVersionsSchema &) = delete;
  DocumentsVersionsSchema & operator=(DocumentsVersionsSchema &&) = delete;

protected:
  DocumentsVersionsSchema();
  ~DocumentsVersionsSchema();
};

/**************************************************************************************************/

class DocumentsVersions : public QObject, public QcRow<DocumentsVersionsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(int document_archive_id READ document_archive_id WRITE set_document_archive_id NOTIFY document_archive_idChanged)
  Q_PROPERTY(int document_geometry_archive_id READ document_geometry_archive_id WRITE set_document_geometry_archive_id NOTIFY document_geometry_archive_idChanged)
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(int document_locales_archive_id READ document_locales_archive_id WRITE set_document_locales_archive_id NOTIFY document_locales_archive_idChanged)
  Q_PROPERTY(int history_metadata_id READ history_metadata_id WRITE set_history_metadata_id NOTIFY history_metadata_idChanged)
  Q_PROPERTY(QString lang READ lang WRITE set_lang NOTIFY langChanged)

public:
  typedef DocumentsVersionsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class DocumentsVersionsPtr;

public:
  DocumentsVersions();
  DocumentsVersions(const DocumentsVersions & other);
  DocumentsVersions(const QJsonObject & json_object); // JSON deserializer
  DocumentsVersions(const QVariantHash & variant_hash);
  DocumentsVersions(const QVariantList & variants);
  DocumentsVersions(const QSqlRecord & record); // SQL deserializer
  DocumentsVersions(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~DocumentsVersions();

  DocumentsVersions & operator=(const DocumentsVersions & other);

  bool operator==(const DocumentsVersions & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  int document_archive_id() const { return m_document_archive_id; }
  void set_document_archive_id(int value);

  int document_geometry_archive_id() const { return m_document_geometry_archive_id; }
  void set_document_geometry_archive_id(int value);

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  int document_locales_archive_id() const { return m_document_locales_archive_id; }
  void set_document_locales_archive_id(int value);

  int history_metadata_id() const { return m_history_metadata_id; }
  void set_history_metadata_id(int value);

  const QString & lang() const { return m_lang; }
  void set_lang(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_document_archive_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ARCHIVE_ID); }
  bool is_document_geometry_archive_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_GEOMETRY_ARCHIVE_ID); }
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_document_locales_archive_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_LOCALES_ARCHIVE_ID); }
  bool is_history_metadata_id_modified() const { return bit_status(Schema::Fields::HISTORY_METADATA_ID); }
  bool is_lang_modified() const { return bit_status(Schema::Fields::LANG); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void document_archive_idChanged();
  void document_geometry_archive_idChanged();
  void document_idChanged();
  void document_locales_archive_idChanged();
  void history_metadata_idChanged();
  void langChanged();

private:
  int m_id;
  int m_document_archive_id;
  int m_document_geometry_archive_id;
  int m_document_id;
  int m_document_locales_archive_id;
  int m_history_metadata_id;
  QString m_lang;

};

QDataStream & operator<<(QDataStream & out, const DocumentsVersions & obj);
QDataStream & operator>>(QDataStream & in, DocumentsVersions & obj);
// qRegisterMetaTypeStreamOperators<DocumentsVersions>("DocumentsVersions");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const DocumentsVersions & obj);
#endif

/**************************************************************************************************/

class DocumentsVersionsPtr
{
public:
  typedef DocumentsVersions Class;

public:
  DocumentsVersionsPtr() : m_ptr() {}
  DocumentsVersionsPtr(const DocumentsVersionsPtr & other) : m_ptr(other.m_ptr) {}
  ~DocumentsVersionsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete DocumentsVersionsPtr of" << *m_ptr;
    // qInfo() << "--- Delete DocumentsVersionsPtr";
    // m_ptr.clear();
  }

  DocumentsVersionsPtr & operator=(const DocumentsVersionsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  DocumentsVersionsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  DocumentsVersionsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  DocumentsVersionsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  DocumentsVersionsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  DocumentsVersionsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  DocumentsVersionsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  DocumentsVersionsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const DocumentsVersionsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const DocumentsVersionsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const DocumentsVersionsPtr & obj);
#endif

/**************************************************************************************************/

class DocumentsVersionsCache : public QObject
{
  Q_OBJECT

public:
  typedef DocumentsVersions * t_Key;
  typedef DocumentsVersionsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  DocumentsVersionsCache();
  ~DocumentsVersionsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class DocumentsVersionsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef DocumentsVersionsPtr Item;
  typedef QList<Item> ItemList;

public:
  DocumentsVersionsModel();
  DocumentsVersionsModel(const ItemList & items);
  ~DocumentsVersionsModel();

  // Fixme: use DocumentsVersionsSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    DOCUMENT_ARCHIVE_ID,
    DOCUMENT_GEOMETRY_ARCHIVE_ID,
    DOCUMENT_ID,
    DOCUMENT_LOCALES_ARCHIVE_ID,
    HISTORY_METADATA_ID,
    LANG
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class Images;
class ImagesPtr;

/**************************************************************************************************/

class ImagesSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACTIVITIES,
    AUTHOR,
    CAMERA_NAME,
    CATEGORIES,
    DATE_TIME,
    ELEVATION,
    EXPOSURE_TIME,
    FILE_SIZE,
    FILENAME,
    FNUMBER,
    FOCAL_LENGTH,
    HEIGHT,
    IMAGE_TYPE,
    ISO_SPEED,
    WIDTH
  };
  static const int NUMBER_OF_FIELDS = 16;

public:
  static ImagesSchema & instance()
  {
    static ImagesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  ImagesSchema(const ImagesSchema &) = delete;
  ImagesSchema(ImagesSchema &&) = delete;
  ImagesSchema & operator=(const ImagesSchema &) = delete;
  ImagesSchema & operator=(ImagesSchema &&) = delete;

protected:
  ImagesSchema();
  ~ImagesSchema();
};

/**************************************************************************************************/

class Images : public QObject, public QcRow<ImagesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QString author READ author WRITE set_author NOTIFY authorChanged)
  Q_PROPERTY(QString camera_name READ camera_name WRITE set_camera_name NOTIFY camera_nameChanged)
  Q_PROPERTY(QStringList categories READ categories WRITE set_categories NOTIFY categoriesChanged)
  Q_PROPERTY(QDateTime date_time READ date_time WRITE set_date_time NOTIFY date_timeChanged)
  Q_PROPERTY(int elevation READ elevation WRITE set_elevation NOTIFY elevationChanged)
  Q_PROPERTY(qreal exposure_time READ exposure_time WRITE set_exposure_time NOTIFY exposure_timeChanged)
  Q_PROPERTY(int file_size READ file_size WRITE set_file_size NOTIFY file_sizeChanged)
  Q_PROPERTY(QString filename READ filename WRITE set_filename NOTIFY filenameChanged)
  Q_PROPERTY(qreal fnumber READ fnumber WRITE set_fnumber NOTIFY fnumberChanged)
  Q_PROPERTY(qreal focal_length READ focal_length WRITE set_focal_length NOTIFY focal_lengthChanged)
  Q_PROPERTY(int height READ height WRITE set_height NOTIFY heightChanged)
  Q_PROPERTY(QString image_type READ image_type WRITE set_image_type NOTIFY image_typeChanged)
  Q_PROPERTY(int iso_speed READ iso_speed WRITE set_iso_speed NOTIFY iso_speedChanged)
  Q_PROPERTY(int width READ width WRITE set_width NOTIFY widthChanged)

public:
  typedef ImagesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class ImagesPtr;

public:
  Images();
  Images(const Images & other);
  Images(const QJsonObject & json_object); // JSON deserializer
  Images(const QVariantHash & variant_hash);
  Images(const QVariantList & variants);
  Images(const QSqlRecord & record); // SQL deserializer
  Images(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Images();

  Images & operator=(const Images & other);

  bool operator==(const Images & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QString & author() const { return m_author; }
  void set_author(const QString & value);

  const QString & camera_name() const { return m_camera_name; }
  void set_camera_name(const QString & value);

  const QStringList & categories() const { return m_categories; }
  void set_categories(const QStringList & value);

  const QDateTime & date_time() const { return m_date_time; }
  void set_date_time(const QDateTime & value);

  int elevation() const { return m_elevation; }
  void set_elevation(int value);

  qreal exposure_time() const { return m_exposure_time; }
  void set_exposure_time(qreal value);

  int file_size() const { return m_file_size; }
  void set_file_size(int value);

  const QString & filename() const { return m_filename; }
  void set_filename(const QString & value);

  qreal fnumber() const { return m_fnumber; }
  void set_fnumber(qreal value);

  qreal focal_length() const { return m_focal_length; }
  void set_focal_length(qreal value);

  int height() const { return m_height; }
  void set_height(int value);

  const QString & image_type() const { return m_image_type; }
  void set_image_type(const QString & value);

  int iso_speed() const { return m_iso_speed; }
  void set_iso_speed(int value);

  int width() const { return m_width; }
  void set_width(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_author_modified() const { return bit_status(Schema::Fields::AUTHOR); }
  bool is_camera_name_modified() const { return bit_status(Schema::Fields::CAMERA_NAME); }
  bool is_categories_modified() const { return bit_status(Schema::Fields::CATEGORIES); }
  bool is_date_time_modified() const { return bit_status(Schema::Fields::DATE_TIME); }
  bool is_elevation_modified() const { return bit_status(Schema::Fields::ELEVATION); }
  bool is_exposure_time_modified() const { return bit_status(Schema::Fields::EXPOSURE_TIME); }
  bool is_file_size_modified() const { return bit_status(Schema::Fields::FILE_SIZE); }
  bool is_filename_modified() const { return bit_status(Schema::Fields::FILENAME); }
  bool is_fnumber_modified() const { return bit_status(Schema::Fields::FNUMBER); }
  bool is_focal_length_modified() const { return bit_status(Schema::Fields::FOCAL_LENGTH); }
  bool is_height_modified() const { return bit_status(Schema::Fields::HEIGHT); }
  bool is_image_type_modified() const { return bit_status(Schema::Fields::IMAGE_TYPE); }
  bool is_iso_speed_modified() const { return bit_status(Schema::Fields::ISO_SPEED); }
  bool is_width_modified() const { return bit_status(Schema::Fields::WIDTH); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void activitiesChanged();
  void authorChanged();
  void camera_nameChanged();
  void categoriesChanged();
  void date_timeChanged();
  void elevationChanged();
  void exposure_timeChanged();
  void file_sizeChanged();
  void filenameChanged();
  void fnumberChanged();
  void focal_lengthChanged();
  void heightChanged();
  void image_typeChanged();
  void iso_speedChanged();
  void widthChanged();

private:
  int m_document_id;
  QStringList m_activities;
  QString m_author;
  QString m_camera_name;
  QStringList m_categories;
  QDateTime m_date_time;
  int m_elevation;
  qreal m_exposure_time;
  int m_file_size;
  QString m_filename;
  qreal m_fnumber;
  qreal m_focal_length;
  int m_height;
  QString m_image_type;
  int m_iso_speed;
  int m_width;

};

QDataStream & operator<<(QDataStream & out, const Images & obj);
QDataStream & operator>>(QDataStream & in, Images & obj);
// qRegisterMetaTypeStreamOperators<Images>("Images");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Images & obj);
#endif

/**************************************************************************************************/

class ImagesPtr
{
public:
  typedef Images Class;

public:
  ImagesPtr() : m_ptr() {}
  ImagesPtr(const ImagesPtr & other) : m_ptr(other.m_ptr) {}
  ~ImagesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete ImagesPtr of" << *m_ptr;
    // qInfo() << "--- Delete ImagesPtr";
    // m_ptr.clear();
  }

  ImagesPtr & operator=(const ImagesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  ImagesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  ImagesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  ImagesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  ImagesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  ImagesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  ImagesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  ImagesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const ImagesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const ImagesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const ImagesPtr & obj);
#endif

/**************************************************************************************************/

class ImagesCache : public QObject
{
  Q_OBJECT

public:
  typedef Images * t_Key;
  typedef ImagesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  ImagesCache();
  ~ImagesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class ImagesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef ImagesPtr Item;
  typedef QList<Item> ItemList;

public:
  ImagesModel();
  ImagesModel(const ItemList & items);
  ~ImagesModel();

  // Fixme: use ImagesSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACTIVITIES,
    AUTHOR,
    CAMERA_NAME,
    CATEGORIES,
    DATE_TIME,
    ELEVATION,
    EXPOSURE_TIME,
    FILE_SIZE,
    FILENAME,
    FNUMBER,
    FOCAL_LENGTH,
    HEIGHT,
    IMAGE_TYPE,
    ISO_SPEED,
    WIDTH
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class MapAssociations;
class MapAssociationsPtr;

/**************************************************************************************************/

class MapAssociationsSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    TOPO_MAP_ID
  };
  static const int NUMBER_OF_FIELDS = 2;

public:
  static MapAssociationsSchema & instance()
  {
    static MapAssociationsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  MapAssociationsSchema(const MapAssociationsSchema &) = delete;
  MapAssociationsSchema(MapAssociationsSchema &&) = delete;
  MapAssociationsSchema & operator=(const MapAssociationsSchema &) = delete;
  MapAssociationsSchema & operator=(MapAssociationsSchema &&) = delete;

protected:
  MapAssociationsSchema();
  ~MapAssociationsSchema();
};

/**************************************************************************************************/

class MapAssociations : public QObject, public QcRow<MapAssociationsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(int topo_map_id READ topo_map_id WRITE set_topo_map_id NOTIFY topo_map_idChanged)

public:
  typedef MapAssociationsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class MapAssociationsPtr;

public:
  MapAssociations();
  MapAssociations(const MapAssociations & other);
  MapAssociations(const QJsonObject & json_object); // JSON deserializer
  MapAssociations(const QVariantHash & variant_hash);
  MapAssociations(const QVariantList & variants);
  MapAssociations(const QSqlRecord & record); // SQL deserializer
  MapAssociations(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~MapAssociations();

  MapAssociations & operator=(const MapAssociations & other);

  bool operator==(const MapAssociations & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  int topo_map_id() const { return m_topo_map_id; }
  void set_topo_map_id(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_topo_map_id_modified() const { return bit_status(Schema::Fields::TOPO_MAP_ID); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void topo_map_idChanged();

private:
  int m_document_id;
  int m_topo_map_id;

};

QDataStream & operator<<(QDataStream & out, const MapAssociations & obj);
QDataStream & operator>>(QDataStream & in, MapAssociations & obj);
// qRegisterMetaTypeStreamOperators<MapAssociations>("MapAssociations");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const MapAssociations & obj);
#endif

/**************************************************************************************************/

class MapAssociationsPtr
{
public:
  typedef MapAssociations Class;

public:
  MapAssociationsPtr() : m_ptr() {}
  MapAssociationsPtr(const MapAssociationsPtr & other) : m_ptr(other.m_ptr) {}
  ~MapAssociationsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete MapAssociationsPtr of" << *m_ptr;
    // qInfo() << "--- Delete MapAssociationsPtr";
    // m_ptr.clear();
  }

  MapAssociationsPtr & operator=(const MapAssociationsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  MapAssociationsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  MapAssociationsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  MapAssociationsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  MapAssociationsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  MapAssociationsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  MapAssociationsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  MapAssociationsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const MapAssociationsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const MapAssociationsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const MapAssociationsPtr & obj);
#endif

/**************************************************************************************************/

class MapAssociationsCache : public QObject
{
  Q_OBJECT

public:
  typedef MapAssociations * t_Key;
  typedef MapAssociationsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  MapAssociationsCache();
  ~MapAssociationsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class MapAssociationsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef MapAssociationsPtr Item;
  typedef QList<Item> ItemList;

public:
  MapAssociationsModel();
  MapAssociationsModel(const ItemList & items);
  ~MapAssociationsModel();

  // Fixme: use MapAssociationsSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    TOPO_MAP_ID
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class Maps;
class MapsPtr;

/**************************************************************************************************/

class MapsSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    CODE,
    EDITOR,
    SCALE
  };
  static const int NUMBER_OF_FIELDS = 4;

public:
  static MapsSchema & instance()
  {
    static MapsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  MapsSchema(const MapsSchema &) = delete;
  MapsSchema(MapsSchema &&) = delete;
  MapsSchema & operator=(const MapsSchema &) = delete;
  MapsSchema & operator=(MapsSchema &&) = delete;

protected:
  MapsSchema();
  ~MapsSchema();
};

/**************************************************************************************************/

class Maps : public QObject, public QcRow<MapsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QString code READ code WRITE set_code NOTIFY codeChanged)
  Q_PROPERTY(QString editor READ editor WRITE set_editor NOTIFY editorChanged)
  Q_PROPERTY(QString scale READ scale WRITE set_scale NOTIFY scaleChanged)

public:
  typedef MapsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class MapsPtr;

public:
  Maps();
  Maps(const Maps & other);
  Maps(const QJsonObject & json_object); // JSON deserializer
  Maps(const QVariantHash & variant_hash);
  Maps(const QVariantList & variants);
  Maps(const QSqlRecord & record); // SQL deserializer
  Maps(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Maps();

  Maps & operator=(const Maps & other);

  bool operator==(const Maps & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QString & code() const { return m_code; }
  void set_code(const QString & value);

  const QString & editor() const { return m_editor; }
  void set_editor(const QString & value);

  const QString & scale() const { return m_scale; }
  void set_scale(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_code_modified() const { return bit_status(Schema::Fields::CODE); }
  bool is_editor_modified() const { return bit_status(Schema::Fields::EDITOR); }
  bool is_scale_modified() const { return bit_status(Schema::Fields::SCALE); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void codeChanged();
  void editorChanged();
  void scaleChanged();

private:
  int m_document_id;
  QString m_code;
  QString m_editor;
  QString m_scale;

};

QDataStream & operator<<(QDataStream & out, const Maps & obj);
QDataStream & operator>>(QDataStream & in, Maps & obj);
// qRegisterMetaTypeStreamOperators<Maps>("Maps");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Maps & obj);
#endif

/**************************************************************************************************/

class MapsPtr
{
public:
  typedef Maps Class;

public:
  MapsPtr() : m_ptr() {}
  MapsPtr(const MapsPtr & other) : m_ptr(other.m_ptr) {}
  ~MapsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete MapsPtr of" << *m_ptr;
    // qInfo() << "--- Delete MapsPtr";
    // m_ptr.clear();
  }

  MapsPtr & operator=(const MapsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  MapsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  MapsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  MapsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  MapsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  MapsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  MapsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  MapsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const MapsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const MapsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const MapsPtr & obj);
#endif

/**************************************************************************************************/

class MapsCache : public QObject
{
  Q_OBJECT

public:
  typedef Maps * t_Key;
  typedef MapsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  MapsCache();
  ~MapsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class MapsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef MapsPtr Item;
  typedef QList<Item> ItemList;

public:
  MapsModel();
  MapsModel(const ItemList & items);
  ~MapsModel();

  // Fixme: use MapsSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    CODE,
    EDITOR,
    SCALE
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class Outings;
class OutingsPtr;

/**************************************************************************************************/

class OutingsSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACCESS_CONDITION,
    ACTIVITIES,
    AVALANCHE_SIGNS,
    CONDITION_RATING,
    DATE_END,
    DATE_START,
    DISABLE_COMMENTS,
    ELEVATION_ACCESS,
    ELEVATION_DOWN_SNOW,
    ELEVATION_MAX,
    ELEVATION_MIN,
    ELEVATION_UP_SNOW,
    FREQUENTATION,
    GLACIER_RATING,
    HEIGHT_DIFF_DOWN,
    HEIGHT_DIFF_UP,
    HUT_STATUS,
    LENGTH_TOTAL,
    LIFT_STATUS,
    PARTIAL_TRIP,
    PARTICIPANT_COUNT,
    PUBLIC_TRANSPORT,
    SNOW_QUALITY,
    SNOW_QUANTITY
  };
  static const int NUMBER_OF_FIELDS = 25;

public:
  static OutingsSchema & instance()
  {
    static OutingsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  OutingsSchema(const OutingsSchema &) = delete;
  OutingsSchema(OutingsSchema &&) = delete;
  OutingsSchema & operator=(const OutingsSchema &) = delete;
  OutingsSchema & operator=(OutingsSchema &&) = delete;

protected:
  OutingsSchema();
  ~OutingsSchema();
};

/**************************************************************************************************/

class Outings : public QObject, public QcRow<OutingsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QString access_condition READ access_condition WRITE set_access_condition NOTIFY access_conditionChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QStringList avalanche_signs READ avalanche_signs WRITE set_avalanche_signs NOTIFY avalanche_signsChanged)
  Q_PROPERTY(QString condition_rating READ condition_rating WRITE set_condition_rating NOTIFY condition_ratingChanged)
  Q_PROPERTY(QDate date_end READ date_end WRITE set_date_end NOTIFY date_endChanged)
  Q_PROPERTY(QDate date_start READ date_start WRITE set_date_start NOTIFY date_startChanged)
  Q_PROPERTY(bool disable_comments READ disable_comments WRITE set_disable_comments NOTIFY disable_commentsChanged)
  Q_PROPERTY(int elevation_access READ elevation_access WRITE set_elevation_access NOTIFY elevation_accessChanged)
  Q_PROPERTY(int elevation_down_snow READ elevation_down_snow WRITE set_elevation_down_snow NOTIFY elevation_down_snowChanged)
  Q_PROPERTY(int elevation_max READ elevation_max WRITE set_elevation_max NOTIFY elevation_maxChanged)
  Q_PROPERTY(int elevation_min READ elevation_min WRITE set_elevation_min NOTIFY elevation_minChanged)
  Q_PROPERTY(int elevation_up_snow READ elevation_up_snow WRITE set_elevation_up_snow NOTIFY elevation_up_snowChanged)
  Q_PROPERTY(QString frequentation READ frequentation WRITE set_frequentation NOTIFY frequentationChanged)
  Q_PROPERTY(QString glacier_rating READ glacier_rating WRITE set_glacier_rating NOTIFY glacier_ratingChanged)
  Q_PROPERTY(int height_diff_down READ height_diff_down WRITE set_height_diff_down NOTIFY height_diff_downChanged)
  Q_PROPERTY(int height_diff_up READ height_diff_up WRITE set_height_diff_up NOTIFY height_diff_upChanged)
  Q_PROPERTY(QString hut_status READ hut_status WRITE set_hut_status NOTIFY hut_statusChanged)
  Q_PROPERTY(int length_total READ length_total WRITE set_length_total NOTIFY length_totalChanged)
  Q_PROPERTY(QString lift_status READ lift_status WRITE set_lift_status NOTIFY lift_statusChanged)
  Q_PROPERTY(bool partial_trip READ partial_trip WRITE set_partial_trip NOTIFY partial_tripChanged)
  Q_PROPERTY(int participant_count READ participant_count WRITE set_participant_count NOTIFY participant_countChanged)
  Q_PROPERTY(bool public_transport READ public_transport WRITE set_public_transport NOTIFY public_transportChanged)
  Q_PROPERTY(QString snow_quality READ snow_quality WRITE set_snow_quality NOTIFY snow_qualityChanged)
  Q_PROPERTY(QString snow_quantity READ snow_quantity WRITE set_snow_quantity NOTIFY snow_quantityChanged)

public:
  typedef OutingsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class OutingsPtr;

public:
  Outings();
  Outings(const Outings & other);
  Outings(const QJsonObject & json_object); // JSON deserializer
  Outings(const QVariantHash & variant_hash);
  Outings(const QVariantList & variants);
  Outings(const QSqlRecord & record); // SQL deserializer
  Outings(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Outings();

  Outings & operator=(const Outings & other);

  bool operator==(const Outings & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QString & access_condition() const { return m_access_condition; }
  void set_access_condition(const QString & value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QStringList & avalanche_signs() const { return m_avalanche_signs; }
  void set_avalanche_signs(const QStringList & value);

  const QString & condition_rating() const { return m_condition_rating; }
  void set_condition_rating(const QString & value);

  const QDate & date_end() const { return m_date_end; }
  void set_date_end(const QDate & value);

  const QDate & date_start() const { return m_date_start; }
  void set_date_start(const QDate & value);

  bool disable_comments() const { return m_disable_comments; }
  void set_disable_comments(bool value);

  int elevation_access() const { return m_elevation_access; }
  void set_elevation_access(int value);

  int elevation_down_snow() const { return m_elevation_down_snow; }
  void set_elevation_down_snow(int value);

  int elevation_max() const { return m_elevation_max; }
  void set_elevation_max(int value);

  int elevation_min() const { return m_elevation_min; }
  void set_elevation_min(int value);

  int elevation_up_snow() const { return m_elevation_up_snow; }
  void set_elevation_up_snow(int value);

  const QString & frequentation() const { return m_frequentation; }
  void set_frequentation(const QString & value);

  const QString & glacier_rating() const { return m_glacier_rating; }
  void set_glacier_rating(const QString & value);

  int height_diff_down() const { return m_height_diff_down; }
  void set_height_diff_down(int value);

  int height_diff_up() const { return m_height_diff_up; }
  void set_height_diff_up(int value);

  const QString & hut_status() const { return m_hut_status; }
  void set_hut_status(const QString & value);

  int length_total() const { return m_length_total; }
  void set_length_total(int value);

  const QString & lift_status() const { return m_lift_status; }
  void set_lift_status(const QString & value);

  bool partial_trip() const { return m_partial_trip; }
  void set_partial_trip(bool value);

  int participant_count() const { return m_participant_count; }
  void set_participant_count(int value);

  bool public_transport() const { return m_public_transport; }
  void set_public_transport(bool value);

  const QString & snow_quality() const { return m_snow_quality; }
  void set_snow_quality(const QString & value);

  const QString & snow_quantity() const { return m_snow_quantity; }
  void set_snow_quantity(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_access_condition_modified() const { return bit_status(Schema::Fields::ACCESS_CONDITION); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_avalanche_signs_modified() const { return bit_status(Schema::Fields::AVALANCHE_SIGNS); }
  bool is_condition_rating_modified() const { return bit_status(Schema::Fields::CONDITION_RATING); }
  bool is_date_end_modified() const { return bit_status(Schema::Fields::DATE_END); }
  bool is_date_start_modified() const { return bit_status(Schema::Fields::DATE_START); }
  bool is_disable_comments_modified() const { return bit_status(Schema::Fields::DISABLE_COMMENTS); }
  bool is_elevation_access_modified() const { return bit_status(Schema::Fields::ELEVATION_ACCESS); }
  bool is_elevation_down_snow_modified() const { return bit_status(Schema::Fields::ELEVATION_DOWN_SNOW); }
  bool is_elevation_max_modified() const { return bit_status(Schema::Fields::ELEVATION_MAX); }
  bool is_elevation_min_modified() const { return bit_status(Schema::Fields::ELEVATION_MIN); }
  bool is_elevation_up_snow_modified() const { return bit_status(Schema::Fields::ELEVATION_UP_SNOW); }
  bool is_frequentation_modified() const { return bit_status(Schema::Fields::FREQUENTATION); }
  bool is_glacier_rating_modified() const { return bit_status(Schema::Fields::GLACIER_RATING); }
  bool is_height_diff_down_modified() const { return bit_status(Schema::Fields::HEIGHT_DIFF_DOWN); }
  bool is_height_diff_up_modified() const { return bit_status(Schema::Fields::HEIGHT_DIFF_UP); }
  bool is_hut_status_modified() const { return bit_status(Schema::Fields::HUT_STATUS); }
  bool is_length_total_modified() const { return bit_status(Schema::Fields::LENGTH_TOTAL); }
  bool is_lift_status_modified() const { return bit_status(Schema::Fields::LIFT_STATUS); }
  bool is_partial_trip_modified() const { return bit_status(Schema::Fields::PARTIAL_TRIP); }
  bool is_participant_count_modified() const { return bit_status(Schema::Fields::PARTICIPANT_COUNT); }
  bool is_public_transport_modified() const { return bit_status(Schema::Fields::PUBLIC_TRANSPORT); }
  bool is_snow_quality_modified() const { return bit_status(Schema::Fields::SNOW_QUALITY); }
  bool is_snow_quantity_modified() const { return bit_status(Schema::Fields::SNOW_QUANTITY); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void access_conditionChanged();
  void activitiesChanged();
  void avalanche_signsChanged();
  void condition_ratingChanged();
  void date_endChanged();
  void date_startChanged();
  void disable_commentsChanged();
  void elevation_accessChanged();
  void elevation_down_snowChanged();
  void elevation_maxChanged();
  void elevation_minChanged();
  void elevation_up_snowChanged();
  void frequentationChanged();
  void glacier_ratingChanged();
  void height_diff_downChanged();
  void height_diff_upChanged();
  void hut_statusChanged();
  void length_totalChanged();
  void lift_statusChanged();
  void partial_tripChanged();
  void participant_countChanged();
  void public_transportChanged();
  void snow_qualityChanged();
  void snow_quantityChanged();

private:
  int m_document_id;
  QString m_access_condition;
  QStringList m_activities;
  QStringList m_avalanche_signs;
  QString m_condition_rating;
  QDate m_date_end;
  QDate m_date_start;
  bool m_disable_comments;
  int m_elevation_access;
  int m_elevation_down_snow;
  int m_elevation_max;
  int m_elevation_min;
  int m_elevation_up_snow;
  QString m_frequentation;
  QString m_glacier_rating;
  int m_height_diff_down;
  int m_height_diff_up;
  QString m_hut_status;
  int m_length_total;
  QString m_lift_status;
  bool m_partial_trip;
  int m_participant_count;
  bool m_public_transport;
  QString m_snow_quality;
  QString m_snow_quantity;

};

QDataStream & operator<<(QDataStream & out, const Outings & obj);
QDataStream & operator>>(QDataStream & in, Outings & obj);
// qRegisterMetaTypeStreamOperators<Outings>("Outings");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Outings & obj);
#endif

/**************************************************************************************************/

class OutingsPtr
{
public:
  typedef Outings Class;

public:
  OutingsPtr() : m_ptr() {}
  OutingsPtr(const OutingsPtr & other) : m_ptr(other.m_ptr) {}
  ~OutingsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete OutingsPtr of" << *m_ptr;
    // qInfo() << "--- Delete OutingsPtr";
    // m_ptr.clear();
  }

  OutingsPtr & operator=(const OutingsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  OutingsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  OutingsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  OutingsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  OutingsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  OutingsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  OutingsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  OutingsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const OutingsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const OutingsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const OutingsPtr & obj);
#endif

/**************************************************************************************************/

class OutingsCache : public QObject
{
  Q_OBJECT

public:
  typedef Outings * t_Key;
  typedef OutingsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  OutingsCache();
  ~OutingsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class OutingsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef OutingsPtr Item;
  typedef QList<Item> ItemList;

public:
  OutingsModel();
  OutingsModel(const ItemList & items);
  ~OutingsModel();

  // Fixme: use OutingsSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACCESS_CONDITION,
    ACTIVITIES,
    AVALANCHE_SIGNS,
    CONDITION_RATING,
    DATE_END,
    DATE_START,
    DISABLE_COMMENTS,
    ELEVATION_ACCESS,
    ELEVATION_DOWN_SNOW,
    ELEVATION_MAX,
    ELEVATION_MIN,
    ELEVATION_UP_SNOW,
    FREQUENTATION,
    GLACIER_RATING,
    HEIGHT_DIFF_DOWN,
    HEIGHT_DIFF_UP,
    HUT_STATUS,
    LENGTH_TOTAL,
    LIFT_STATUS,
    PARTIAL_TRIP,
    PARTICIPANT_COUNT,
    PUBLIC_TRANSPORT,
    SNOW_QUALITY,
    SNOW_QUANTITY
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class OutingsLocales;
class OutingsLocalesPtr;

/**************************************************************************************************/

class OutingsLocalesSchema : public QcSchema
{
public:
  enum Fields {
    ID,
    ACCESS_COMMENT,
    AVALANCHES,
    CONDITIONS,
    CONDITIONS_LEVELS,
    HUT_COMMENT,
    PARTICIPANTS,
    ROUTE_DESCRIPTION,
    TIMING,
    WEATHER
  };
  static const int NUMBER_OF_FIELDS = 10;

public:
  static OutingsLocalesSchema & instance()
  {
    static OutingsLocalesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  OutingsLocalesSchema(const OutingsLocalesSchema &) = delete;
  OutingsLocalesSchema(OutingsLocalesSchema &&) = delete;
  OutingsLocalesSchema & operator=(const OutingsLocalesSchema &) = delete;
  OutingsLocalesSchema & operator=(OutingsLocalesSchema &&) = delete;

protected:
  OutingsLocalesSchema();
  ~OutingsLocalesSchema();
};

/**************************************************************************************************/

class OutingsLocales : public QObject, public QcRow<OutingsLocalesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QString access_comment READ access_comment WRITE set_access_comment NOTIFY access_commentChanged)
  Q_PROPERTY(QString avalanches READ avalanches WRITE set_avalanches NOTIFY avalanchesChanged)
  Q_PROPERTY(QString conditions READ conditions WRITE set_conditions NOTIFY conditionsChanged)
  Q_PROPERTY(QString conditions_levels READ conditions_levels WRITE set_conditions_levels NOTIFY conditions_levelsChanged)
  Q_PROPERTY(QString hut_comment READ hut_comment WRITE set_hut_comment NOTIFY hut_commentChanged)
  Q_PROPERTY(QString participants READ participants WRITE set_participants NOTIFY participantsChanged)
  Q_PROPERTY(QString route_description READ route_description WRITE set_route_description NOTIFY route_descriptionChanged)
  Q_PROPERTY(QString timing READ timing WRITE set_timing NOTIFY timingChanged)
  Q_PROPERTY(QString weather READ weather WRITE set_weather NOTIFY weatherChanged)

public:
  typedef OutingsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class OutingsLocalesPtr;

public:
  OutingsLocales();
  OutingsLocales(const OutingsLocales & other);
  OutingsLocales(const QJsonObject & json_object); // JSON deserializer
  OutingsLocales(const QVariantHash & variant_hash);
  OutingsLocales(const QVariantList & variants);
  OutingsLocales(const QSqlRecord & record); // SQL deserializer
  OutingsLocales(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~OutingsLocales();

  OutingsLocales & operator=(const OutingsLocales & other);

  bool operator==(const OutingsLocales & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QString & access_comment() const { return m_access_comment; }
  void set_access_comment(const QString & value);

  const QString & avalanches() const { return m_avalanches; }
  void set_avalanches(const QString & value);

  const QString & conditions() const { return m_conditions; }
  void set_conditions(const QString & value);

  const QString & conditions_levels() const { return m_conditions_levels; }
  void set_conditions_levels(const QString & value);

  const QString & hut_comment() const { return m_hut_comment; }
  void set_hut_comment(const QString & value);

  const QString & participants() const { return m_participants; }
  void set_participants(const QString & value);

  const QString & route_description() const { return m_route_description; }
  void set_route_description(const QString & value);

  const QString & timing() const { return m_timing; }
  void set_timing(const QString & value);

  const QString & weather() const { return m_weather; }
  void set_weather(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_access_comment_modified() const { return bit_status(Schema::Fields::ACCESS_COMMENT); }
  bool is_avalanches_modified() const { return bit_status(Schema::Fields::AVALANCHES); }
  bool is_conditions_modified() const { return bit_status(Schema::Fields::CONDITIONS); }
  bool is_conditions_levels_modified() const { return bit_status(Schema::Fields::CONDITIONS_LEVELS); }
  bool is_hut_comment_modified() const { return bit_status(Schema::Fields::HUT_COMMENT); }
  bool is_participants_modified() const { return bit_status(Schema::Fields::PARTICIPANTS); }
  bool is_route_description_modified() const { return bit_status(Schema::Fields::ROUTE_DESCRIPTION); }
  bool is_timing_modified() const { return bit_status(Schema::Fields::TIMING); }
  bool is_weather_modified() const { return bit_status(Schema::Fields::WEATHER); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void access_commentChanged();
  void avalanchesChanged();
  void conditionsChanged();
  void conditions_levelsChanged();
  void hut_commentChanged();
  void participantsChanged();
  void route_descriptionChanged();
  void timingChanged();
  void weatherChanged();

private:
  int m_id;
  QString m_access_comment;
  QString m_avalanches;
  QString m_conditions;
  QString m_conditions_levels;
  QString m_hut_comment;
  QString m_participants;
  QString m_route_description;
  QString m_timing;
  QString m_weather;

};

QDataStream & operator<<(QDataStream & out, const OutingsLocales & obj);
QDataStream & operator>>(QDataStream & in, OutingsLocales & obj);
// qRegisterMetaTypeStreamOperators<OutingsLocales>("OutingsLocales");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const OutingsLocales & obj);
#endif

/**************************************************************************************************/

class OutingsLocalesPtr
{
public:
  typedef OutingsLocales Class;

public:
  OutingsLocalesPtr() : m_ptr() {}
  OutingsLocalesPtr(const OutingsLocalesPtr & other) : m_ptr(other.m_ptr) {}
  ~OutingsLocalesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete OutingsLocalesPtr of" << *m_ptr;
    // qInfo() << "--- Delete OutingsLocalesPtr";
    // m_ptr.clear();
  }

  OutingsLocalesPtr & operator=(const OutingsLocalesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  OutingsLocalesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  OutingsLocalesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  OutingsLocalesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  OutingsLocalesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  OutingsLocalesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  OutingsLocalesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  OutingsLocalesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const OutingsLocalesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const OutingsLocalesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const OutingsLocalesPtr & obj);
#endif

/**************************************************************************************************/

class OutingsLocalesCache : public QObject
{
  Q_OBJECT

public:
  typedef OutingsLocales * t_Key;
  typedef OutingsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  OutingsLocalesCache();
  ~OutingsLocalesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class OutingsLocalesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef OutingsLocalesPtr Item;
  typedef QList<Item> ItemList;

public:
  OutingsLocalesModel();
  OutingsLocalesModel(const ItemList & items);
  ~OutingsLocalesModel();

  // Fixme: use OutingsLocalesSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    ACCESS_COMMENT,
    AVALANCHES,
    CONDITIONS,
    CONDITIONS_LEVELS,
    HUT_COMMENT,
    PARTICIPANTS,
    ROUTE_DESCRIPTION,
    TIMING,
    WEATHER
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class Routes;
class RoutesPtr;

/**************************************************************************************************/

class RoutesSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACTIVITIES,
    AID_RATING,
    CLIMBING_OUTDOOR_TYPE,
    CONFIGURATION,
    DIFFICULTIES_HEIGHT,
    DURATIONS,
    ELEVATION_MAX,
    ELEVATION_MIN,
    ENGAGEMENT_RATING,
    EQUIPMENT_RATING,
    EXPOSITION_ROCK_RATING,
    GLACIER_GEAR,
    GLOBAL_RATING,
    HEIGHT_DIFF_ACCESS,
    HEIGHT_DIFF_DIFFICULTIES,
    HEIGHT_DIFF_DOWN,
    HEIGHT_DIFF_UP,
    HIKING_MTB_EXPOSITION,
    HIKING_RATING,
    ICE_RATING,
    LABANDE_GLOBAL_RATING,
    LABANDE_SKI_RATING,
    LIFT_ACCESS,
    MAIN_WAYPOINT_ID,
    MIXED_RATING,
    MTB_DOWN_RATING,
    MTB_HEIGHT_DIFF_PORTAGES,
    MTB_LENGTH_ASPHALT,
    MTB_LENGTH_TRAIL,
    MTB_UP_RATING,
    ORIENTATIONS,
    RISK_RATING,
    ROCK_FREE_RATING,
    ROCK_REQUIRED_RATING,
    ROCK_TYPES,
    ROUTE_LENGTH,
    ROUTE_TYPES,
    SKI_EXPOSITION,
    SKI_RATING,
    SLACKLINE_HEIGHT,
    SLACKLINE_TYPE,
    SNOWSHOE_RATING,
    VIA_FERRATA_RATING
  };
  static const int NUMBER_OF_FIELDS = 44;

public:
  static RoutesSchema & instance()
  {
    static RoutesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  RoutesSchema(const RoutesSchema &) = delete;
  RoutesSchema(RoutesSchema &&) = delete;
  RoutesSchema & operator=(const RoutesSchema &) = delete;
  RoutesSchema & operator=(RoutesSchema &&) = delete;

protected:
  RoutesSchema();
  ~RoutesSchema();
};

/**************************************************************************************************/

class Routes : public QObject, public QcRow<RoutesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QString aid_rating READ aid_rating WRITE set_aid_rating NOTIFY aid_ratingChanged)
  Q_PROPERTY(QString climbing_outdoor_type READ climbing_outdoor_type WRITE set_climbing_outdoor_type NOTIFY climbing_outdoor_typeChanged)
  Q_PROPERTY(QStringList configuration READ configuration WRITE set_configuration NOTIFY configurationChanged)
  Q_PROPERTY(int difficulties_height READ difficulties_height WRITE set_difficulties_height NOTIFY difficulties_heightChanged)
  Q_PROPERTY(QStringList durations READ durations WRITE set_durations NOTIFY durationsChanged)
  Q_PROPERTY(int elevation_max READ elevation_max WRITE set_elevation_max NOTIFY elevation_maxChanged)
  Q_PROPERTY(int elevation_min READ elevation_min WRITE set_elevation_min NOTIFY elevation_minChanged)
  Q_PROPERTY(QString engagement_rating READ engagement_rating WRITE set_engagement_rating NOTIFY engagement_ratingChanged)
  Q_PROPERTY(QString equipment_rating READ equipment_rating WRITE set_equipment_rating NOTIFY equipment_ratingChanged)
  Q_PROPERTY(QString exposition_rock_rating READ exposition_rock_rating WRITE set_exposition_rock_rating NOTIFY exposition_rock_ratingChanged)
  Q_PROPERTY(QString glacier_gear READ glacier_gear WRITE set_glacier_gear NOTIFY glacier_gearChanged)
  Q_PROPERTY(QString global_rating READ global_rating WRITE set_global_rating NOTIFY global_ratingChanged)
  Q_PROPERTY(int height_diff_access READ height_diff_access WRITE set_height_diff_access NOTIFY height_diff_accessChanged)
  Q_PROPERTY(int height_diff_difficulties READ height_diff_difficulties WRITE set_height_diff_difficulties NOTIFY height_diff_difficultiesChanged)
  Q_PROPERTY(int height_diff_down READ height_diff_down WRITE set_height_diff_down NOTIFY height_diff_downChanged)
  Q_PROPERTY(int height_diff_up READ height_diff_up WRITE set_height_diff_up NOTIFY height_diff_upChanged)
  Q_PROPERTY(QString hiking_mtb_exposition READ hiking_mtb_exposition WRITE set_hiking_mtb_exposition NOTIFY hiking_mtb_expositionChanged)
  Q_PROPERTY(QString hiking_rating READ hiking_rating WRITE set_hiking_rating NOTIFY hiking_ratingChanged)
  Q_PROPERTY(QString ice_rating READ ice_rating WRITE set_ice_rating NOTIFY ice_ratingChanged)
  Q_PROPERTY(QString labande_global_rating READ labande_global_rating WRITE set_labande_global_rating NOTIFY labande_global_ratingChanged)
  Q_PROPERTY(QString labande_ski_rating READ labande_ski_rating WRITE set_labande_ski_rating NOTIFY labande_ski_ratingChanged)
  Q_PROPERTY(bool lift_access READ lift_access WRITE set_lift_access NOTIFY lift_accessChanged)
  Q_PROPERTY(int main_waypoint_id READ main_waypoint_id WRITE set_main_waypoint_id NOTIFY main_waypoint_idChanged)
  Q_PROPERTY(QString mixed_rating READ mixed_rating WRITE set_mixed_rating NOTIFY mixed_ratingChanged)
  Q_PROPERTY(QString mtb_down_rating READ mtb_down_rating WRITE set_mtb_down_rating NOTIFY mtb_down_ratingChanged)
  Q_PROPERTY(int mtb_height_diff_portages READ mtb_height_diff_portages WRITE set_mtb_height_diff_portages NOTIFY mtb_height_diff_portagesChanged)
  Q_PROPERTY(int mtb_length_asphalt READ mtb_length_asphalt WRITE set_mtb_length_asphalt NOTIFY mtb_length_asphaltChanged)
  Q_PROPERTY(int mtb_length_trail READ mtb_length_trail WRITE set_mtb_length_trail NOTIFY mtb_length_trailChanged)
  Q_PROPERTY(QString mtb_up_rating READ mtb_up_rating WRITE set_mtb_up_rating NOTIFY mtb_up_ratingChanged)
  Q_PROPERTY(QStringList orientations READ orientations WRITE set_orientations NOTIFY orientationsChanged)
  Q_PROPERTY(QString risk_rating READ risk_rating WRITE set_risk_rating NOTIFY risk_ratingChanged)
  Q_PROPERTY(QString rock_free_rating READ rock_free_rating WRITE set_rock_free_rating NOTIFY rock_free_ratingChanged)
  Q_PROPERTY(QString rock_required_rating READ rock_required_rating WRITE set_rock_required_rating NOTIFY rock_required_ratingChanged)
  Q_PROPERTY(QStringList rock_types READ rock_types WRITE set_rock_types NOTIFY rock_typesChanged)
  Q_PROPERTY(int route_length READ route_length WRITE set_route_length NOTIFY route_lengthChanged)
  Q_PROPERTY(QStringList route_types READ route_types WRITE set_route_types NOTIFY route_typesChanged)
  Q_PROPERTY(QString ski_exposition READ ski_exposition WRITE set_ski_exposition NOTIFY ski_expositionChanged)
  Q_PROPERTY(QString ski_rating READ ski_rating WRITE set_ski_rating NOTIFY ski_ratingChanged)
  Q_PROPERTY(int slackline_height READ slackline_height WRITE set_slackline_height NOTIFY slackline_heightChanged)
  Q_PROPERTY(QString slackline_type READ slackline_type WRITE set_slackline_type NOTIFY slackline_typeChanged)
  Q_PROPERTY(QString snowshoe_rating READ snowshoe_rating WRITE set_snowshoe_rating NOTIFY snowshoe_ratingChanged)
  Q_PROPERTY(QString via_ferrata_rating READ via_ferrata_rating WRITE set_via_ferrata_rating NOTIFY via_ferrata_ratingChanged)

public:
  typedef RoutesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class RoutesPtr;

public:
  Routes();
  Routes(const Routes & other);
  Routes(const QJsonObject & json_object); // JSON deserializer
  Routes(const QVariantHash & variant_hash);
  Routes(const QVariantList & variants);
  Routes(const QSqlRecord & record); // SQL deserializer
  Routes(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Routes();

  Routes & operator=(const Routes & other);

  bool operator==(const Routes & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QString & aid_rating() const { return m_aid_rating; }
  void set_aid_rating(const QString & value);

  const QString & climbing_outdoor_type() const { return m_climbing_outdoor_type; }
  void set_climbing_outdoor_type(const QString & value);

  const QStringList & configuration() const { return m_configuration; }
  void set_configuration(const QStringList & value);

  int difficulties_height() const { return m_difficulties_height; }
  void set_difficulties_height(int value);

  const QStringList & durations() const { return m_durations; }
  void set_durations(const QStringList & value);

  int elevation_max() const { return m_elevation_max; }
  void set_elevation_max(int value);

  int elevation_min() const { return m_elevation_min; }
  void set_elevation_min(int value);

  const QString & engagement_rating() const { return m_engagement_rating; }
  void set_engagement_rating(const QString & value);

  const QString & equipment_rating() const { return m_equipment_rating; }
  void set_equipment_rating(const QString & value);

  const QString & exposition_rock_rating() const { return m_exposition_rock_rating; }
  void set_exposition_rock_rating(const QString & value);

  const QString & glacier_gear() const { return m_glacier_gear; }
  void set_glacier_gear(const QString & value);

  const QString & global_rating() const { return m_global_rating; }
  void set_global_rating(const QString & value);

  int height_diff_access() const { return m_height_diff_access; }
  void set_height_diff_access(int value);

  int height_diff_difficulties() const { return m_height_diff_difficulties; }
  void set_height_diff_difficulties(int value);

  int height_diff_down() const { return m_height_diff_down; }
  void set_height_diff_down(int value);

  int height_diff_up() const { return m_height_diff_up; }
  void set_height_diff_up(int value);

  const QString & hiking_mtb_exposition() const { return m_hiking_mtb_exposition; }
  void set_hiking_mtb_exposition(const QString & value);

  const QString & hiking_rating() const { return m_hiking_rating; }
  void set_hiking_rating(const QString & value);

  const QString & ice_rating() const { return m_ice_rating; }
  void set_ice_rating(const QString & value);

  const QString & labande_global_rating() const { return m_labande_global_rating; }
  void set_labande_global_rating(const QString & value);

  const QString & labande_ski_rating() const { return m_labande_ski_rating; }
  void set_labande_ski_rating(const QString & value);

  bool lift_access() const { return m_lift_access; }
  void set_lift_access(bool value);

  int main_waypoint_id() const { return m_main_waypoint_id; }
  void set_main_waypoint_id(int value);

  const QString & mixed_rating() const { return m_mixed_rating; }
  void set_mixed_rating(const QString & value);

  const QString & mtb_down_rating() const { return m_mtb_down_rating; }
  void set_mtb_down_rating(const QString & value);

  int mtb_height_diff_portages() const { return m_mtb_height_diff_portages; }
  void set_mtb_height_diff_portages(int value);

  int mtb_length_asphalt() const { return m_mtb_length_asphalt; }
  void set_mtb_length_asphalt(int value);

  int mtb_length_trail() const { return m_mtb_length_trail; }
  void set_mtb_length_trail(int value);

  const QString & mtb_up_rating() const { return m_mtb_up_rating; }
  void set_mtb_up_rating(const QString & value);

  const QStringList & orientations() const { return m_orientations; }
  void set_orientations(const QStringList & value);

  const QString & risk_rating() const { return m_risk_rating; }
  void set_risk_rating(const QString & value);

  const QString & rock_free_rating() const { return m_rock_free_rating; }
  void set_rock_free_rating(const QString & value);

  const QString & rock_required_rating() const { return m_rock_required_rating; }
  void set_rock_required_rating(const QString & value);

  const QStringList & rock_types() const { return m_rock_types; }
  void set_rock_types(const QStringList & value);

  int route_length() const { return m_route_length; }
  void set_route_length(int value);

  const QStringList & route_types() const { return m_route_types; }
  void set_route_types(const QStringList & value);

  const QString & ski_exposition() const { return m_ski_exposition; }
  void set_ski_exposition(const QString & value);

  const QString & ski_rating() const { return m_ski_rating; }
  void set_ski_rating(const QString & value);

  int slackline_height() const { return m_slackline_height; }
  void set_slackline_height(int value);

  const QString & slackline_type() const { return m_slackline_type; }
  void set_slackline_type(const QString & value);

  const QString & snowshoe_rating() const { return m_snowshoe_rating; }
  void set_snowshoe_rating(const QString & value);

  const QString & via_ferrata_rating() const { return m_via_ferrata_rating; }
  void set_via_ferrata_rating(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_aid_rating_modified() const { return bit_status(Schema::Fields::AID_RATING); }
  bool is_climbing_outdoor_type_modified() const { return bit_status(Schema::Fields::CLIMBING_OUTDOOR_TYPE); }
  bool is_configuration_modified() const { return bit_status(Schema::Fields::CONFIGURATION); }
  bool is_difficulties_height_modified() const { return bit_status(Schema::Fields::DIFFICULTIES_HEIGHT); }
  bool is_durations_modified() const { return bit_status(Schema::Fields::DURATIONS); }
  bool is_elevation_max_modified() const { return bit_status(Schema::Fields::ELEVATION_MAX); }
  bool is_elevation_min_modified() const { return bit_status(Schema::Fields::ELEVATION_MIN); }
  bool is_engagement_rating_modified() const { return bit_status(Schema::Fields::ENGAGEMENT_RATING); }
  bool is_equipment_rating_modified() const { return bit_status(Schema::Fields::EQUIPMENT_RATING); }
  bool is_exposition_rock_rating_modified() const { return bit_status(Schema::Fields::EXPOSITION_ROCK_RATING); }
  bool is_glacier_gear_modified() const { return bit_status(Schema::Fields::GLACIER_GEAR); }
  bool is_global_rating_modified() const { return bit_status(Schema::Fields::GLOBAL_RATING); }
  bool is_height_diff_access_modified() const { return bit_status(Schema::Fields::HEIGHT_DIFF_ACCESS); }
  bool is_height_diff_difficulties_modified() const { return bit_status(Schema::Fields::HEIGHT_DIFF_DIFFICULTIES); }
  bool is_height_diff_down_modified() const { return bit_status(Schema::Fields::HEIGHT_DIFF_DOWN); }
  bool is_height_diff_up_modified() const { return bit_status(Schema::Fields::HEIGHT_DIFF_UP); }
  bool is_hiking_mtb_exposition_modified() const { return bit_status(Schema::Fields::HIKING_MTB_EXPOSITION); }
  bool is_hiking_rating_modified() const { return bit_status(Schema::Fields::HIKING_RATING); }
  bool is_ice_rating_modified() const { return bit_status(Schema::Fields::ICE_RATING); }
  bool is_labande_global_rating_modified() const { return bit_status(Schema::Fields::LABANDE_GLOBAL_RATING); }
  bool is_labande_ski_rating_modified() const { return bit_status(Schema::Fields::LABANDE_SKI_RATING); }
  bool is_lift_access_modified() const { return bit_status(Schema::Fields::LIFT_ACCESS); }
  bool is_main_waypoint_id_modified() const { return bit_status(Schema::Fields::MAIN_WAYPOINT_ID); }
  bool is_mixed_rating_modified() const { return bit_status(Schema::Fields::MIXED_RATING); }
  bool is_mtb_down_rating_modified() const { return bit_status(Schema::Fields::MTB_DOWN_RATING); }
  bool is_mtb_height_diff_portages_modified() const { return bit_status(Schema::Fields::MTB_HEIGHT_DIFF_PORTAGES); }
  bool is_mtb_length_asphalt_modified() const { return bit_status(Schema::Fields::MTB_LENGTH_ASPHALT); }
  bool is_mtb_length_trail_modified() const { return bit_status(Schema::Fields::MTB_LENGTH_TRAIL); }
  bool is_mtb_up_rating_modified() const { return bit_status(Schema::Fields::MTB_UP_RATING); }
  bool is_orientations_modified() const { return bit_status(Schema::Fields::ORIENTATIONS); }
  bool is_risk_rating_modified() const { return bit_status(Schema::Fields::RISK_RATING); }
  bool is_rock_free_rating_modified() const { return bit_status(Schema::Fields::ROCK_FREE_RATING); }
  bool is_rock_required_rating_modified() const { return bit_status(Schema::Fields::ROCK_REQUIRED_RATING); }
  bool is_rock_types_modified() const { return bit_status(Schema::Fields::ROCK_TYPES); }
  bool is_route_length_modified() const { return bit_status(Schema::Fields::ROUTE_LENGTH); }
  bool is_route_types_modified() const { return bit_status(Schema::Fields::ROUTE_TYPES); }
  bool is_ski_exposition_modified() const { return bit_status(Schema::Fields::SKI_EXPOSITION); }
  bool is_ski_rating_modified() const { return bit_status(Schema::Fields::SKI_RATING); }
  bool is_slackline_height_modified() const { return bit_status(Schema::Fields::SLACKLINE_HEIGHT); }
  bool is_slackline_type_modified() const { return bit_status(Schema::Fields::SLACKLINE_TYPE); }
  bool is_snowshoe_rating_modified() const { return bit_status(Schema::Fields::SNOWSHOE_RATING); }
  bool is_via_ferrata_rating_modified() const { return bit_status(Schema::Fields::VIA_FERRATA_RATING); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void activitiesChanged();
  void aid_ratingChanged();
  void climbing_outdoor_typeChanged();
  void configurationChanged();
  void difficulties_heightChanged();
  void durationsChanged();
  void elevation_maxChanged();
  void elevation_minChanged();
  void engagement_ratingChanged();
  void equipment_ratingChanged();
  void exposition_rock_ratingChanged();
  void glacier_gearChanged();
  void global_ratingChanged();
  void height_diff_accessChanged();
  void height_diff_difficultiesChanged();
  void height_diff_downChanged();
  void height_diff_upChanged();
  void hiking_mtb_expositionChanged();
  void hiking_ratingChanged();
  void ice_ratingChanged();
  void labande_global_ratingChanged();
  void labande_ski_ratingChanged();
  void lift_accessChanged();
  void main_waypoint_idChanged();
  void mixed_ratingChanged();
  void mtb_down_ratingChanged();
  void mtb_height_diff_portagesChanged();
  void mtb_length_asphaltChanged();
  void mtb_length_trailChanged();
  void mtb_up_ratingChanged();
  void orientationsChanged();
  void risk_ratingChanged();
  void rock_free_ratingChanged();
  void rock_required_ratingChanged();
  void rock_typesChanged();
  void route_lengthChanged();
  void route_typesChanged();
  void ski_expositionChanged();
  void ski_ratingChanged();
  void slackline_heightChanged();
  void slackline_typeChanged();
  void snowshoe_ratingChanged();
  void via_ferrata_ratingChanged();

private:
  int m_document_id;
  QStringList m_activities;
  QString m_aid_rating;
  QString m_climbing_outdoor_type;
  QStringList m_configuration;
  int m_difficulties_height;
  QStringList m_durations;
  int m_elevation_max;
  int m_elevation_min;
  QString m_engagement_rating;
  QString m_equipment_rating;
  QString m_exposition_rock_rating;
  QString m_glacier_gear;
  QString m_global_rating;
  int m_height_diff_access;
  int m_height_diff_difficulties;
  int m_height_diff_down;
  int m_height_diff_up;
  QString m_hiking_mtb_exposition;
  QString m_hiking_rating;
  QString m_ice_rating;
  QString m_labande_global_rating;
  QString m_labande_ski_rating;
  bool m_lift_access;
  int m_main_waypoint_id;
  QString m_mixed_rating;
  QString m_mtb_down_rating;
  int m_mtb_height_diff_portages;
  int m_mtb_length_asphalt;
  int m_mtb_length_trail;
  QString m_mtb_up_rating;
  QStringList m_orientations;
  QString m_risk_rating;
  QString m_rock_free_rating;
  QString m_rock_required_rating;
  QStringList m_rock_types;
  int m_route_length;
  QStringList m_route_types;
  QString m_ski_exposition;
  QString m_ski_rating;
  int m_slackline_height;
  QString m_slackline_type;
  QString m_snowshoe_rating;
  QString m_via_ferrata_rating;

};

QDataStream & operator<<(QDataStream & out, const Routes & obj);
QDataStream & operator>>(QDataStream & in, Routes & obj);
// qRegisterMetaTypeStreamOperators<Routes>("Routes");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Routes & obj);
#endif

/**************************************************************************************************/

class RoutesPtr
{
public:
  typedef Routes Class;

public:
  RoutesPtr() : m_ptr() {}
  RoutesPtr(const RoutesPtr & other) : m_ptr(other.m_ptr) {}
  ~RoutesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete RoutesPtr of" << *m_ptr;
    // qInfo() << "--- Delete RoutesPtr";
    // m_ptr.clear();
  }

  RoutesPtr & operator=(const RoutesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  RoutesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  RoutesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  RoutesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  RoutesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  RoutesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  RoutesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  RoutesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const RoutesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const RoutesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const RoutesPtr & obj);
#endif

/**************************************************************************************************/

class RoutesCache : public QObject
{
  Q_OBJECT

public:
  typedef Routes * t_Key;
  typedef RoutesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  RoutesCache();
  ~RoutesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class RoutesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef RoutesPtr Item;
  typedef QList<Item> ItemList;

public:
  RoutesModel();
  RoutesModel(const ItemList & items);
  ~RoutesModel();

  // Fixme: use RoutesSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACTIVITIES,
    AID_RATING,
    CLIMBING_OUTDOOR_TYPE,
    CONFIGURATION,
    DIFFICULTIES_HEIGHT,
    DURATIONS,
    ELEVATION_MAX,
    ELEVATION_MIN,
    ENGAGEMENT_RATING,
    EQUIPMENT_RATING,
    EXPOSITION_ROCK_RATING,
    GLACIER_GEAR,
    GLOBAL_RATING,
    HEIGHT_DIFF_ACCESS,
    HEIGHT_DIFF_DIFFICULTIES,
    HEIGHT_DIFF_DOWN,
    HEIGHT_DIFF_UP,
    HIKING_MTB_EXPOSITION,
    HIKING_RATING,
    ICE_RATING,
    LABANDE_GLOBAL_RATING,
    LABANDE_SKI_RATING,
    LIFT_ACCESS,
    MAIN_WAYPOINT_ID,
    MIXED_RATING,
    MTB_DOWN_RATING,
    MTB_HEIGHT_DIFF_PORTAGES,
    MTB_LENGTH_ASPHALT,
    MTB_LENGTH_TRAIL,
    MTB_UP_RATING,
    ORIENTATIONS,
    RISK_RATING,
    ROCK_FREE_RATING,
    ROCK_REQUIRED_RATING,
    ROCK_TYPES,
    ROUTE_LENGTH,
    ROUTE_TYPES,
    SKI_EXPOSITION,
    SKI_RATING,
    SLACKLINE_HEIGHT,
    SLACKLINE_TYPE,
    SNOWSHOE_RATING,
    VIA_FERRATA_RATING
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class RoutesLocales;
class RoutesLocalesPtr;

/**************************************************************************************************/

class RoutesLocalesSchema : public QcSchema
{
public:
  enum Fields {
    ID,
    EXTERNAL_RESOURCES,
    GEAR,
    REMARKS,
    ROUTE_HISTORY,
    SLACKLINE_ANCHOR1,
    SLACKLINE_ANCHOR2,
    SLOPE,
    TITLE_PREFIX
  };
  static const int NUMBER_OF_FIELDS = 9;

public:
  static RoutesLocalesSchema & instance()
  {
    static RoutesLocalesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  RoutesLocalesSchema(const RoutesLocalesSchema &) = delete;
  RoutesLocalesSchema(RoutesLocalesSchema &&) = delete;
  RoutesLocalesSchema & operator=(const RoutesLocalesSchema &) = delete;
  RoutesLocalesSchema & operator=(RoutesLocalesSchema &&) = delete;

protected:
  RoutesLocalesSchema();
  ~RoutesLocalesSchema();
};

/**************************************************************************************************/

class RoutesLocales : public QObject, public QcRow<RoutesLocalesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QString external_resources READ external_resources WRITE set_external_resources NOTIFY external_resourcesChanged)
  Q_PROPERTY(QString gear READ gear WRITE set_gear NOTIFY gearChanged)
  Q_PROPERTY(QString remarks READ remarks WRITE set_remarks NOTIFY remarksChanged)
  Q_PROPERTY(QString route_history READ route_history WRITE set_route_history NOTIFY route_historyChanged)
  Q_PROPERTY(QString slackline_anchor1 READ slackline_anchor1 WRITE set_slackline_anchor1 NOTIFY slackline_anchor1Changed)
  Q_PROPERTY(QString slackline_anchor2 READ slackline_anchor2 WRITE set_slackline_anchor2 NOTIFY slackline_anchor2Changed)
  Q_PROPERTY(QString slope READ slope WRITE set_slope NOTIFY slopeChanged)
  Q_PROPERTY(QString title_prefix READ title_prefix WRITE set_title_prefix NOTIFY title_prefixChanged)

public:
  typedef RoutesLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class RoutesLocalesPtr;

public:
  RoutesLocales();
  RoutesLocales(const RoutesLocales & other);
  RoutesLocales(const QJsonObject & json_object); // JSON deserializer
  RoutesLocales(const QVariantHash & variant_hash);
  RoutesLocales(const QVariantList & variants);
  RoutesLocales(const QSqlRecord & record); // SQL deserializer
  RoutesLocales(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~RoutesLocales();

  RoutesLocales & operator=(const RoutesLocales & other);

  bool operator==(const RoutesLocales & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QString & external_resources() const { return m_external_resources; }
  void set_external_resources(const QString & value);

  const QString & gear() const { return m_gear; }
  void set_gear(const QString & value);

  const QString & remarks() const { return m_remarks; }
  void set_remarks(const QString & value);

  const QString & route_history() const { return m_route_history; }
  void set_route_history(const QString & value);

  const QString & slackline_anchor1() const { return m_slackline_anchor1; }
  void set_slackline_anchor1(const QString & value);

  const QString & slackline_anchor2() const { return m_slackline_anchor2; }
  void set_slackline_anchor2(const QString & value);

  const QString & slope() const { return m_slope; }
  void set_slope(const QString & value);

  const QString & title_prefix() const { return m_title_prefix; }
  void set_title_prefix(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_external_resources_modified() const { return bit_status(Schema::Fields::EXTERNAL_RESOURCES); }
  bool is_gear_modified() const { return bit_status(Schema::Fields::GEAR); }
  bool is_remarks_modified() const { return bit_status(Schema::Fields::REMARKS); }
  bool is_route_history_modified() const { return bit_status(Schema::Fields::ROUTE_HISTORY); }
  bool is_slackline_anchor1_modified() const { return bit_status(Schema::Fields::SLACKLINE_ANCHOR1); }
  bool is_slackline_anchor2_modified() const { return bit_status(Schema::Fields::SLACKLINE_ANCHOR2); }
  bool is_slope_modified() const { return bit_status(Schema::Fields::SLOPE); }
  bool is_title_prefix_modified() const { return bit_status(Schema::Fields::TITLE_PREFIX); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void external_resourcesChanged();
  void gearChanged();
  void remarksChanged();
  void route_historyChanged();
  void slackline_anchor1Changed();
  void slackline_anchor2Changed();
  void slopeChanged();
  void title_prefixChanged();

private:
  int m_id;
  QString m_external_resources;
  QString m_gear;
  QString m_remarks;
  QString m_route_history;
  QString m_slackline_anchor1;
  QString m_slackline_anchor2;
  QString m_slope;
  QString m_title_prefix;

};

QDataStream & operator<<(QDataStream & out, const RoutesLocales & obj);
QDataStream & operator>>(QDataStream & in, RoutesLocales & obj);
// qRegisterMetaTypeStreamOperators<RoutesLocales>("RoutesLocales");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const RoutesLocales & obj);
#endif

/**************************************************************************************************/

class RoutesLocalesPtr
{
public:
  typedef RoutesLocales Class;

public:
  RoutesLocalesPtr() : m_ptr() {}
  RoutesLocalesPtr(const RoutesLocalesPtr & other) : m_ptr(other.m_ptr) {}
  ~RoutesLocalesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete RoutesLocalesPtr of" << *m_ptr;
    // qInfo() << "--- Delete RoutesLocalesPtr";
    // m_ptr.clear();
  }

  RoutesLocalesPtr & operator=(const RoutesLocalesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  RoutesLocalesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  RoutesLocalesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  RoutesLocalesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  RoutesLocalesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  RoutesLocalesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  RoutesLocalesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  RoutesLocalesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const RoutesLocalesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const RoutesLocalesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const RoutesLocalesPtr & obj);
#endif

/**************************************************************************************************/

class RoutesLocalesCache : public QObject
{
  Q_OBJECT

public:
  typedef RoutesLocales * t_Key;
  typedef RoutesLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  RoutesLocalesCache();
  ~RoutesLocalesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class RoutesLocalesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef RoutesLocalesPtr Item;
  typedef QList<Item> ItemList;

public:
  RoutesLocalesModel();
  RoutesLocalesModel(const ItemList & items);
  ~RoutesLocalesModel();

  // Fixme: use RoutesLocalesSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    EXTERNAL_RESOURCES,
    GEAR,
    REMARKS,
    ROUTE_HISTORY,
    SLACKLINE_ANCHOR1,
    SLACKLINE_ANCHOR2,
    SLOPE,
    TITLE_PREFIX
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class User;
class UserPtr;

/**************************************************************************************************/

class UserSchema : public QcSchema
{
public:
  enum Fields {
    ID,
    BLOCKED,
    EMAIL,
    EMAIL_TO_VALIDATE,
    EMAIL_VALIDATED,
    FEED_FILTER_ACTIVITIES,
    FEED_FOLLOWED_ONLY,
    FORUM_USERNAME,
    IS_PROFILE_PUBLIC,
    LANG,
    LAST_MODIFIED,
    MODERATOR,
    NAME,
    PASSWORD,
    USERNAME,
    VALIDATION_NONCE,
    VALIDATION_NONCE_EXPIRE
  };
  static const int NUMBER_OF_FIELDS = 17;

public:
  static UserSchema & instance()
  {
    static UserSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  UserSchema(const UserSchema &) = delete;
  UserSchema(UserSchema &&) = delete;
  UserSchema & operator=(const UserSchema &) = delete;
  UserSchema & operator=(UserSchema &&) = delete;

protected:
  UserSchema();
  ~UserSchema();
};

/**************************************************************************************************/

class User : public QObject, public QcRow<UserSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(bool blocked READ blocked WRITE set_blocked NOTIFY blockedChanged)
  Q_PROPERTY(QString email READ email WRITE set_email NOTIFY emailChanged)
  Q_PROPERTY(QString email_to_validate READ email_to_validate WRITE set_email_to_validate NOTIFY email_to_validateChanged)
  Q_PROPERTY(bool email_validated READ email_validated WRITE set_email_validated NOTIFY email_validatedChanged)
  Q_PROPERTY(QStringList feed_filter_activities READ feed_filter_activities WRITE set_feed_filter_activities NOTIFY feed_filter_activitiesChanged)
  Q_PROPERTY(bool feed_followed_only READ feed_followed_only WRITE set_feed_followed_only NOTIFY feed_followed_onlyChanged)
  Q_PROPERTY(QString forum_username READ forum_username WRITE set_forum_username NOTIFY forum_usernameChanged)
  Q_PROPERTY(bool is_profile_public READ is_profile_public WRITE set_is_profile_public NOTIFY is_profile_publicChanged)
  Q_PROPERTY(QString lang READ lang WRITE set_lang NOTIFY langChanged)
  Q_PROPERTY(QDateTime last_modified READ last_modified WRITE set_last_modified NOTIFY last_modifiedChanged)
  Q_PROPERTY(bool moderator READ moderator WRITE set_moderator NOTIFY moderatorChanged)
  Q_PROPERTY(QString name READ name WRITE set_name NOTIFY nameChanged)
  Q_PROPERTY(QString password READ password WRITE set_password NOTIFY passwordChanged)
  Q_PROPERTY(QString username READ username WRITE set_username NOTIFY usernameChanged)
  Q_PROPERTY(QString validation_nonce READ validation_nonce WRITE set_validation_nonce NOTIFY validation_nonceChanged)
  Q_PROPERTY(QDateTime validation_nonce_expire READ validation_nonce_expire WRITE set_validation_nonce_expire NOTIFY validation_nonce_expireChanged)

public:
  typedef UserPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class UserPtr;

public:
  User();
  User(const User & other);
  User(const QJsonObject & json_object); // JSON deserializer
  User(const QVariantHash & variant_hash);
  User(const QVariantList & variants);
  User(const QSqlRecord & record); // SQL deserializer
  User(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~User();

  User & operator=(const User & other);

  bool operator==(const User & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  bool blocked() const { return m_blocked; }
  void set_blocked(bool value);

  const QString & email() const { return m_email; }
  void set_email(const QString & value);

  const QString & email_to_validate() const { return m_email_to_validate; }
  void set_email_to_validate(const QString & value);

  bool email_validated() const { return m_email_validated; }
  void set_email_validated(bool value);

  const QStringList & feed_filter_activities() const { return m_feed_filter_activities; }
  void set_feed_filter_activities(const QStringList & value);

  bool feed_followed_only() const { return m_feed_followed_only; }
  void set_feed_followed_only(bool value);

  const QString & forum_username() const { return m_forum_username; }
  void set_forum_username(const QString & value);

  bool is_profile_public() const { return m_is_profile_public; }
  void set_is_profile_public(bool value);

  const QString & lang() const { return m_lang; }
  void set_lang(const QString & value);

  const QDateTime & last_modified() const { return m_last_modified; }
  void set_last_modified(const QDateTime & value);

  bool moderator() const { return m_moderator; }
  void set_moderator(bool value);

  const QString & name() const { return m_name; }
  void set_name(const QString & value);

  const QString & password() const { return m_password; }
  void set_password(const QString & value);

  const QString & username() const { return m_username; }
  void set_username(const QString & value);

  const QString & validation_nonce() const { return m_validation_nonce; }
  void set_validation_nonce(const QString & value);

  const QDateTime & validation_nonce_expire() const { return m_validation_nonce_expire; }
  void set_validation_nonce_expire(const QDateTime & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_blocked_modified() const { return bit_status(Schema::Fields::BLOCKED); }
  bool is_email_modified() const { return bit_status(Schema::Fields::EMAIL); }
  bool is_email_to_validate_modified() const { return bit_status(Schema::Fields::EMAIL_TO_VALIDATE); }
  bool is_email_validated_modified() const { return bit_status(Schema::Fields::EMAIL_VALIDATED); }
  bool is_feed_filter_activities_modified() const { return bit_status(Schema::Fields::FEED_FILTER_ACTIVITIES); }
  bool is_feed_followed_only_modified() const { return bit_status(Schema::Fields::FEED_FOLLOWED_ONLY); }
  bool is_forum_username_modified() const { return bit_status(Schema::Fields::FORUM_USERNAME); }
  bool is_is_profile_public_modified() const { return bit_status(Schema::Fields::IS_PROFILE_PUBLIC); }
  bool is_lang_modified() const { return bit_status(Schema::Fields::LANG); }
  bool is_last_modified_modified() const { return bit_status(Schema::Fields::LAST_MODIFIED); }
  bool is_moderator_modified() const { return bit_status(Schema::Fields::MODERATOR); }
  bool is_name_modified() const { return bit_status(Schema::Fields::NAME); }
  bool is_password_modified() const { return bit_status(Schema::Fields::PASSWORD); }
  bool is_username_modified() const { return bit_status(Schema::Fields::USERNAME); }
  bool is_validation_nonce_modified() const { return bit_status(Schema::Fields::VALIDATION_NONCE); }
  bool is_validation_nonce_expire_modified() const { return bit_status(Schema::Fields::VALIDATION_NONCE_EXPIRE); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void blockedChanged();
  void emailChanged();
  void email_to_validateChanged();
  void email_validatedChanged();
  void feed_filter_activitiesChanged();
  void feed_followed_onlyChanged();
  void forum_usernameChanged();
  void is_profile_publicChanged();
  void langChanged();
  void last_modifiedChanged();
  void moderatorChanged();
  void nameChanged();
  void passwordChanged();
  void usernameChanged();
  void validation_nonceChanged();
  void validation_nonce_expireChanged();

private:
  int m_id;
  bool m_blocked;
  QString m_email;
  QString m_email_to_validate;
  bool m_email_validated;
  QStringList m_feed_filter_activities;
  bool m_feed_followed_only;
  QString m_forum_username;
  bool m_is_profile_public;
  QString m_lang;
  QDateTime m_last_modified;
  bool m_moderator;
  QString m_name;
  QString m_password;
  QString m_username;
  QString m_validation_nonce;
  QDateTime m_validation_nonce_expire;

};

QDataStream & operator<<(QDataStream & out, const User & obj);
QDataStream & operator>>(QDataStream & in, User & obj);
// qRegisterMetaTypeStreamOperators<User>("User");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const User & obj);
#endif

/**************************************************************************************************/

class UserPtr
{
public:
  typedef User Class;

public:
  UserPtr() : m_ptr() {}
  UserPtr(const UserPtr & other) : m_ptr(other.m_ptr) {}
  ~UserPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete UserPtr of" << *m_ptr;
    // qInfo() << "--- Delete UserPtr";
    // m_ptr.clear();
  }

  UserPtr & operator=(const UserPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  UserPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  UserPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  UserPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  UserPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  UserPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  UserPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  UserPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const UserPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const UserPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const UserPtr & obj);
#endif

/**************************************************************************************************/

class UserCache : public QObject
{
  Q_OBJECT

public:
  typedef User * t_Key;
  typedef UserPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  UserCache();
  ~UserCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class UserModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef UserPtr Item;
  typedef QList<Item> ItemList;

public:
  UserModel();
  UserModel(const ItemList & items);
  ~UserModel();

  // Fixme: use UserSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    BLOCKED,
    EMAIL,
    EMAIL_TO_VALIDATE,
    EMAIL_VALIDATED,
    FEED_FILTER_ACTIVITIES,
    FEED_FOLLOWED_ONLY,
    FORUM_USERNAME,
    IS_PROFILE_PUBLIC,
    LANG,
    LAST_MODIFIED,
    MODERATOR,
    NAME,
    PASSWORD,
    USERNAME,
    VALIDATION_NONCE,
    VALIDATION_NONCE_EXPIRE
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class UserProfiles;
class UserProfilesPtr;

/**************************************************************************************************/

class UserProfilesSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACTIVITIES,
    CATEGORIES
  };
  static const int NUMBER_OF_FIELDS = 3;

public:
  static UserProfilesSchema & instance()
  {
    static UserProfilesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  UserProfilesSchema(const UserProfilesSchema &) = delete;
  UserProfilesSchema(UserProfilesSchema &&) = delete;
  UserProfilesSchema & operator=(const UserProfilesSchema &) = delete;
  UserProfilesSchema & operator=(UserProfilesSchema &&) = delete;

protected:
  UserProfilesSchema();
  ~UserProfilesSchema();
};

/**************************************************************************************************/

class UserProfiles : public QObject, public QcRow<UserProfilesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QStringList categories READ categories WRITE set_categories NOTIFY categoriesChanged)

public:
  typedef UserProfilesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class UserProfilesPtr;

public:
  UserProfiles();
  UserProfiles(const UserProfiles & other);
  UserProfiles(const QJsonObject & json_object); // JSON deserializer
  UserProfiles(const QVariantHash & variant_hash);
  UserProfiles(const QVariantList & variants);
  UserProfiles(const QSqlRecord & record); // SQL deserializer
  UserProfiles(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~UserProfiles();

  UserProfiles & operator=(const UserProfiles & other);

  bool operator==(const UserProfiles & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QStringList & categories() const { return m_categories; }
  void set_categories(const QStringList & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_categories_modified() const { return bit_status(Schema::Fields::CATEGORIES); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void activitiesChanged();
  void categoriesChanged();

private:
  int m_document_id;
  QStringList m_activities;
  QStringList m_categories;

};

QDataStream & operator<<(QDataStream & out, const UserProfiles & obj);
QDataStream & operator>>(QDataStream & in, UserProfiles & obj);
// qRegisterMetaTypeStreamOperators<UserProfiles>("UserProfiles");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const UserProfiles & obj);
#endif

/**************************************************************************************************/

class UserProfilesPtr
{
public:
  typedef UserProfiles Class;

public:
  UserProfilesPtr() : m_ptr() {}
  UserProfilesPtr(const UserProfilesPtr & other) : m_ptr(other.m_ptr) {}
  ~UserProfilesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete UserProfilesPtr of" << *m_ptr;
    // qInfo() << "--- Delete UserProfilesPtr";
    // m_ptr.clear();
  }

  UserProfilesPtr & operator=(const UserProfilesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  UserProfilesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  UserProfilesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  UserProfilesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  UserProfilesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  UserProfilesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  UserProfilesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  UserProfilesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const UserProfilesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const UserProfilesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const UserProfilesPtr & obj);
#endif

/**************************************************************************************************/

class UserProfilesCache : public QObject
{
  Q_OBJECT

public:
  typedef UserProfiles * t_Key;
  typedef UserProfilesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  UserProfilesCache();
  ~UserProfilesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class UserProfilesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef UserProfilesPtr Item;
  typedef QList<Item> ItemList;

public:
  UserProfilesModel();
  UserProfilesModel(const ItemList & items);
  ~UserProfilesModel();

  // Fixme: use UserProfilesSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACTIVITIES,
    CATEGORIES
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class Waypoints;
class WaypointsPtr;

/**************************************************************************************************/

class WaypointsSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACCESS_TIME,
    BEST_PERIODS,
    BLANKET_UNSTAFFED,
    CAPACITY,
    CAPACITY_STAFFED,
    CHILDREN_PROOF,
    CLIMBING_INDOOR_TYPES,
    CLIMBING_OUTDOOR_TYPES,
    CLIMBING_RATING_MAX,
    CLIMBING_RATING_MEDIAN,
    CLIMBING_RATING_MIN,
    CLIMBING_STYLES,
    CUSTODIANSHIP,
    ELEVATION,
    ELEVATION_MIN,
    EQUIPMENT_RATINGS,
    EXPOSITION_RATING,
    GAS_UNSTAFFED,
    GROUND_TYPES,
    HEATING_UNSTAFFED,
    HEIGHT_MAX,
    HEIGHT_MEDIAN,
    HEIGHT_MIN,
    LENGTH,
    LIFT_ACCESS,
    MAPS_INFO,
    MATRESS_UNSTAFFED,
    ORIENTATIONS,
    PARAGLIDING_RATING,
    PARKING_FEE,
    PHONE,
    PHONE_CUSTODIAN,
    PRODUCT_TYPES,
    PROMINENCE,
    PUBLIC_TRANSPORTATION_RATING,
    PUBLIC_TRANSPORTATION_TYPES,
    RAIN_PROOF,
    ROCK_TYPES,
    ROUTES_QUANTITY,
    SLACKLINE_LENGTH_MAX,
    SLACKLINE_LENGTH_MIN,
    SLACKLINE_TYPES,
    SLOPE,
    SNOW_CLEARANCE_RATING,
    URL,
    WAYPOINT_TYPE,
    WEATHER_STATION_TYPES
  };
  static const int NUMBER_OF_FIELDS = 48;

public:
  static WaypointsSchema & instance()
  {
    static WaypointsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  WaypointsSchema(const WaypointsSchema &) = delete;
  WaypointsSchema(WaypointsSchema &&) = delete;
  WaypointsSchema & operator=(const WaypointsSchema &) = delete;
  WaypointsSchema & operator=(WaypointsSchema &&) = delete;

protected:
  WaypointsSchema();
  ~WaypointsSchema();
};

/**************************************************************************************************/

class Waypoints : public QObject, public QcRow<WaypointsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QString access_time READ access_time WRITE set_access_time NOTIFY access_timeChanged)
  Q_PROPERTY(QStringList best_periods READ best_periods WRITE set_best_periods NOTIFY best_periodsChanged)
  Q_PROPERTY(bool blanket_unstaffed READ blanket_unstaffed WRITE set_blanket_unstaffed NOTIFY blanket_unstaffedChanged)
  Q_PROPERTY(int capacity READ capacity WRITE set_capacity NOTIFY capacityChanged)
  Q_PROPERTY(int capacity_staffed READ capacity_staffed WRITE set_capacity_staffed NOTIFY capacity_staffedChanged)
  Q_PROPERTY(QString children_proof READ children_proof WRITE set_children_proof NOTIFY children_proofChanged)
  Q_PROPERTY(QStringList climbing_indoor_types READ climbing_indoor_types WRITE set_climbing_indoor_types NOTIFY climbing_indoor_typesChanged)
  Q_PROPERTY(QStringList climbing_outdoor_types READ climbing_outdoor_types WRITE set_climbing_outdoor_types NOTIFY climbing_outdoor_typesChanged)
  Q_PROPERTY(QString climbing_rating_max READ climbing_rating_max WRITE set_climbing_rating_max NOTIFY climbing_rating_maxChanged)
  Q_PROPERTY(QString climbing_rating_median READ climbing_rating_median WRITE set_climbing_rating_median NOTIFY climbing_rating_medianChanged)
  Q_PROPERTY(QString climbing_rating_min READ climbing_rating_min WRITE set_climbing_rating_min NOTIFY climbing_rating_minChanged)
  Q_PROPERTY(QStringList climbing_styles READ climbing_styles WRITE set_climbing_styles NOTIFY climbing_stylesChanged)
  Q_PROPERTY(QString custodianship READ custodianship WRITE set_custodianship NOTIFY custodianshipChanged)
  Q_PROPERTY(int elevation READ elevation WRITE set_elevation NOTIFY elevationChanged)
  Q_PROPERTY(int elevation_min READ elevation_min WRITE set_elevation_min NOTIFY elevation_minChanged)
  Q_PROPERTY(QStringList equipment_ratings READ equipment_ratings WRITE set_equipment_ratings NOTIFY equipment_ratingsChanged)
  Q_PROPERTY(QString exposition_rating READ exposition_rating WRITE set_exposition_rating NOTIFY exposition_ratingChanged)
  Q_PROPERTY(bool gas_unstaffed READ gas_unstaffed WRITE set_gas_unstaffed NOTIFY gas_unstaffedChanged)
  Q_PROPERTY(QStringList ground_types READ ground_types WRITE set_ground_types NOTIFY ground_typesChanged)
  Q_PROPERTY(bool heating_unstaffed READ heating_unstaffed WRITE set_heating_unstaffed NOTIFY heating_unstaffedChanged)
  Q_PROPERTY(int height_max READ height_max WRITE set_height_max NOTIFY height_maxChanged)
  Q_PROPERTY(int height_median READ height_median WRITE set_height_median NOTIFY height_medianChanged)
  Q_PROPERTY(int height_min READ height_min WRITE set_height_min NOTIFY height_minChanged)
  Q_PROPERTY(int length READ length WRITE set_length NOTIFY lengthChanged)
  Q_PROPERTY(bool lift_access READ lift_access WRITE set_lift_access NOTIFY lift_accessChanged)
  Q_PROPERTY(QString maps_info READ maps_info WRITE set_maps_info NOTIFY maps_infoChanged)
  Q_PROPERTY(bool matress_unstaffed READ matress_unstaffed WRITE set_matress_unstaffed NOTIFY matress_unstaffedChanged)
  Q_PROPERTY(QStringList orientations READ orientations WRITE set_orientations NOTIFY orientationsChanged)
  Q_PROPERTY(QChar paragliding_rating READ paragliding_rating WRITE set_paragliding_rating NOTIFY paragliding_ratingChanged)
  Q_PROPERTY(QString parking_fee READ parking_fee WRITE set_parking_fee NOTIFY parking_feeChanged)
  Q_PROPERTY(QString phone READ phone WRITE set_phone NOTIFY phoneChanged)
  Q_PROPERTY(QString phone_custodian READ phone_custodian WRITE set_phone_custodian NOTIFY phone_custodianChanged)
  Q_PROPERTY(QStringList product_types READ product_types WRITE set_product_types NOTIFY product_typesChanged)
  Q_PROPERTY(int prominence READ prominence WRITE set_prominence NOTIFY prominenceChanged)
  Q_PROPERTY(QString public_transportation_rating READ public_transportation_rating WRITE set_public_transportation_rating NOTIFY public_transportation_ratingChanged)
  Q_PROPERTY(QStringList public_transportation_types READ public_transportation_types WRITE set_public_transportation_types NOTIFY public_transportation_typesChanged)
  Q_PROPERTY(QString rain_proof READ rain_proof WRITE set_rain_proof NOTIFY rain_proofChanged)
  Q_PROPERTY(QStringList rock_types READ rock_types WRITE set_rock_types NOTIFY rock_typesChanged)
  Q_PROPERTY(int routes_quantity READ routes_quantity WRITE set_routes_quantity NOTIFY routes_quantityChanged)
  Q_PROPERTY(int slackline_length_max READ slackline_length_max WRITE set_slackline_length_max NOTIFY slackline_length_maxChanged)
  Q_PROPERTY(int slackline_length_min READ slackline_length_min WRITE set_slackline_length_min NOTIFY slackline_length_minChanged)
  Q_PROPERTY(QStringList slackline_types READ slackline_types WRITE set_slackline_types NOTIFY slackline_typesChanged)
  Q_PROPERTY(int slope READ slope WRITE set_slope NOTIFY slopeChanged)
  Q_PROPERTY(QString snow_clearance_rating READ snow_clearance_rating WRITE set_snow_clearance_rating NOTIFY snow_clearance_ratingChanged)
  Q_PROPERTY(QString url READ url WRITE set_url NOTIFY urlChanged)
  Q_PROPERTY(QString waypoint_type READ waypoint_type WRITE set_waypoint_type NOTIFY waypoint_typeChanged)
  Q_PROPERTY(QStringList weather_station_types READ weather_station_types WRITE set_weather_station_types NOTIFY weather_station_typesChanged)

public:
  typedef WaypointsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class WaypointsPtr;

public:
  Waypoints();
  Waypoints(const Waypoints & other);
  Waypoints(const QJsonObject & json_object); // JSON deserializer
  Waypoints(const QVariantHash & variant_hash);
  Waypoints(const QVariantList & variants);
  Waypoints(const QSqlRecord & record); // SQL deserializer
  Waypoints(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Waypoints();

  Waypoints & operator=(const Waypoints & other);

  bool operator==(const Waypoints & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QString & access_time() const { return m_access_time; }
  void set_access_time(const QString & value);

  const QStringList & best_periods() const { return m_best_periods; }
  void set_best_periods(const QStringList & value);

  bool blanket_unstaffed() const { return m_blanket_unstaffed; }
  void set_blanket_unstaffed(bool value);

  int capacity() const { return m_capacity; }
  void set_capacity(int value);

  int capacity_staffed() const { return m_capacity_staffed; }
  void set_capacity_staffed(int value);

  const QString & children_proof() const { return m_children_proof; }
  void set_children_proof(const QString & value);

  const QStringList & climbing_indoor_types() const { return m_climbing_indoor_types; }
  void set_climbing_indoor_types(const QStringList & value);

  const QStringList & climbing_outdoor_types() const { return m_climbing_outdoor_types; }
  void set_climbing_outdoor_types(const QStringList & value);

  const QString & climbing_rating_max() const { return m_climbing_rating_max; }
  void set_climbing_rating_max(const QString & value);

  const QString & climbing_rating_median() const { return m_climbing_rating_median; }
  void set_climbing_rating_median(const QString & value);

  const QString & climbing_rating_min() const { return m_climbing_rating_min; }
  void set_climbing_rating_min(const QString & value);

  const QStringList & climbing_styles() const { return m_climbing_styles; }
  void set_climbing_styles(const QStringList & value);

  const QString & custodianship() const { return m_custodianship; }
  void set_custodianship(const QString & value);

  int elevation() const { return m_elevation; }
  void set_elevation(int value);

  int elevation_min() const { return m_elevation_min; }
  void set_elevation_min(int value);

  const QStringList & equipment_ratings() const { return m_equipment_ratings; }
  void set_equipment_ratings(const QStringList & value);

  const QString & exposition_rating() const { return m_exposition_rating; }
  void set_exposition_rating(const QString & value);

  bool gas_unstaffed() const { return m_gas_unstaffed; }
  void set_gas_unstaffed(bool value);

  const QStringList & ground_types() const { return m_ground_types; }
  void set_ground_types(const QStringList & value);

  bool heating_unstaffed() const { return m_heating_unstaffed; }
  void set_heating_unstaffed(bool value);

  int height_max() const { return m_height_max; }
  void set_height_max(int value);

  int height_median() const { return m_height_median; }
  void set_height_median(int value);

  int height_min() const { return m_height_min; }
  void set_height_min(int value);

  int length() const { return m_length; }
  void set_length(int value);

  bool lift_access() const { return m_lift_access; }
  void set_lift_access(bool value);

  const QString & maps_info() const { return m_maps_info; }
  void set_maps_info(const QString & value);

  bool matress_unstaffed() const { return m_matress_unstaffed; }
  void set_matress_unstaffed(bool value);

  const QStringList & orientations() const { return m_orientations; }
  void set_orientations(const QStringList & value);

  const QChar & paragliding_rating() const { return m_paragliding_rating; }
  void set_paragliding_rating(const QChar & value);

  const QString & parking_fee() const { return m_parking_fee; }
  void set_parking_fee(const QString & value);

  const QString & phone() const { return m_phone; }
  void set_phone(const QString & value);

  const QString & phone_custodian() const { return m_phone_custodian; }
  void set_phone_custodian(const QString & value);

  const QStringList & product_types() const { return m_product_types; }
  void set_product_types(const QStringList & value);

  int prominence() const { return m_prominence; }
  void set_prominence(int value);

  const QString & public_transportation_rating() const { return m_public_transportation_rating; }
  void set_public_transportation_rating(const QString & value);

  const QStringList & public_transportation_types() const { return m_public_transportation_types; }
  void set_public_transportation_types(const QStringList & value);

  const QString & rain_proof() const { return m_rain_proof; }
  void set_rain_proof(const QString & value);

  const QStringList & rock_types() const { return m_rock_types; }
  void set_rock_types(const QStringList & value);

  int routes_quantity() const { return m_routes_quantity; }
  void set_routes_quantity(int value);

  int slackline_length_max() const { return m_slackline_length_max; }
  void set_slackline_length_max(int value);

  int slackline_length_min() const { return m_slackline_length_min; }
  void set_slackline_length_min(int value);

  const QStringList & slackline_types() const { return m_slackline_types; }
  void set_slackline_types(const QStringList & value);

  int slope() const { return m_slope; }
  void set_slope(int value);

  const QString & snow_clearance_rating() const { return m_snow_clearance_rating; }
  void set_snow_clearance_rating(const QString & value);

  const QString & url() const { return m_url; }
  void set_url(const QString & value);

  const QString & waypoint_type() const { return m_waypoint_type; }
  void set_waypoint_type(const QString & value);

  const QStringList & weather_station_types() const { return m_weather_station_types; }
  void set_weather_station_types(const QStringList & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_access_time_modified() const { return bit_status(Schema::Fields::ACCESS_TIME); }
  bool is_best_periods_modified() const { return bit_status(Schema::Fields::BEST_PERIODS); }
  bool is_blanket_unstaffed_modified() const { return bit_status(Schema::Fields::BLANKET_UNSTAFFED); }
  bool is_capacity_modified() const { return bit_status(Schema::Fields::CAPACITY); }
  bool is_capacity_staffed_modified() const { return bit_status(Schema::Fields::CAPACITY_STAFFED); }
  bool is_children_proof_modified() const { return bit_status(Schema::Fields::CHILDREN_PROOF); }
  bool is_climbing_indoor_types_modified() const { return bit_status(Schema::Fields::CLIMBING_INDOOR_TYPES); }
  bool is_climbing_outdoor_types_modified() const { return bit_status(Schema::Fields::CLIMBING_OUTDOOR_TYPES); }
  bool is_climbing_rating_max_modified() const { return bit_status(Schema::Fields::CLIMBING_RATING_MAX); }
  bool is_climbing_rating_median_modified() const { return bit_status(Schema::Fields::CLIMBING_RATING_MEDIAN); }
  bool is_climbing_rating_min_modified() const { return bit_status(Schema::Fields::CLIMBING_RATING_MIN); }
  bool is_climbing_styles_modified() const { return bit_status(Schema::Fields::CLIMBING_STYLES); }
  bool is_custodianship_modified() const { return bit_status(Schema::Fields::CUSTODIANSHIP); }
  bool is_elevation_modified() const { return bit_status(Schema::Fields::ELEVATION); }
  bool is_elevation_min_modified() const { return bit_status(Schema::Fields::ELEVATION_MIN); }
  bool is_equipment_ratings_modified() const { return bit_status(Schema::Fields::EQUIPMENT_RATINGS); }
  bool is_exposition_rating_modified() const { return bit_status(Schema::Fields::EXPOSITION_RATING); }
  bool is_gas_unstaffed_modified() const { return bit_status(Schema::Fields::GAS_UNSTAFFED); }
  bool is_ground_types_modified() const { return bit_status(Schema::Fields::GROUND_TYPES); }
  bool is_heating_unstaffed_modified() const { return bit_status(Schema::Fields::HEATING_UNSTAFFED); }
  bool is_height_max_modified() const { return bit_status(Schema::Fields::HEIGHT_MAX); }
  bool is_height_median_modified() const { return bit_status(Schema::Fields::HEIGHT_MEDIAN); }
  bool is_height_min_modified() const { return bit_status(Schema::Fields::HEIGHT_MIN); }
  bool is_length_modified() const { return bit_status(Schema::Fields::LENGTH); }
  bool is_lift_access_modified() const { return bit_status(Schema::Fields::LIFT_ACCESS); }
  bool is_maps_info_modified() const { return bit_status(Schema::Fields::MAPS_INFO); }
  bool is_matress_unstaffed_modified() const { return bit_status(Schema::Fields::MATRESS_UNSTAFFED); }
  bool is_orientations_modified() const { return bit_status(Schema::Fields::ORIENTATIONS); }
  bool is_paragliding_rating_modified() const { return bit_status(Schema::Fields::PARAGLIDING_RATING); }
  bool is_parking_fee_modified() const { return bit_status(Schema::Fields::PARKING_FEE); }
  bool is_phone_modified() const { return bit_status(Schema::Fields::PHONE); }
  bool is_phone_custodian_modified() const { return bit_status(Schema::Fields::PHONE_CUSTODIAN); }
  bool is_product_types_modified() const { return bit_status(Schema::Fields::PRODUCT_TYPES); }
  bool is_prominence_modified() const { return bit_status(Schema::Fields::PROMINENCE); }
  bool is_public_transportation_rating_modified() const { return bit_status(Schema::Fields::PUBLIC_TRANSPORTATION_RATING); }
  bool is_public_transportation_types_modified() const { return bit_status(Schema::Fields::PUBLIC_TRANSPORTATION_TYPES); }
  bool is_rain_proof_modified() const { return bit_status(Schema::Fields::RAIN_PROOF); }
  bool is_rock_types_modified() const { return bit_status(Schema::Fields::ROCK_TYPES); }
  bool is_routes_quantity_modified() const { return bit_status(Schema::Fields::ROUTES_QUANTITY); }
  bool is_slackline_length_max_modified() const { return bit_status(Schema::Fields::SLACKLINE_LENGTH_MAX); }
  bool is_slackline_length_min_modified() const { return bit_status(Schema::Fields::SLACKLINE_LENGTH_MIN); }
  bool is_slackline_types_modified() const { return bit_status(Schema::Fields::SLACKLINE_TYPES); }
  bool is_slope_modified() const { return bit_status(Schema::Fields::SLOPE); }
  bool is_snow_clearance_rating_modified() const { return bit_status(Schema::Fields::SNOW_CLEARANCE_RATING); }
  bool is_url_modified() const { return bit_status(Schema::Fields::URL); }
  bool is_waypoint_type_modified() const { return bit_status(Schema::Fields::WAYPOINT_TYPE); }
  bool is_weather_station_types_modified() const { return bit_status(Schema::Fields::WEATHER_STATION_TYPES); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void access_timeChanged();
  void best_periodsChanged();
  void blanket_unstaffedChanged();
  void capacityChanged();
  void capacity_staffedChanged();
  void children_proofChanged();
  void climbing_indoor_typesChanged();
  void climbing_outdoor_typesChanged();
  void climbing_rating_maxChanged();
  void climbing_rating_medianChanged();
  void climbing_rating_minChanged();
  void climbing_stylesChanged();
  void custodianshipChanged();
  void elevationChanged();
  void elevation_minChanged();
  void equipment_ratingsChanged();
  void exposition_ratingChanged();
  void gas_unstaffedChanged();
  void ground_typesChanged();
  void heating_unstaffedChanged();
  void height_maxChanged();
  void height_medianChanged();
  void height_minChanged();
  void lengthChanged();
  void lift_accessChanged();
  void maps_infoChanged();
  void matress_unstaffedChanged();
  void orientationsChanged();
  void paragliding_ratingChanged();
  void parking_feeChanged();
  void phoneChanged();
  void phone_custodianChanged();
  void product_typesChanged();
  void prominenceChanged();
  void public_transportation_ratingChanged();
  void public_transportation_typesChanged();
  void rain_proofChanged();
  void rock_typesChanged();
  void routes_quantityChanged();
  void slackline_length_maxChanged();
  void slackline_length_minChanged();
  void slackline_typesChanged();
  void slopeChanged();
  void snow_clearance_ratingChanged();
  void urlChanged();
  void waypoint_typeChanged();
  void weather_station_typesChanged();

private:
  int m_document_id;
  QString m_access_time;
  QStringList m_best_periods;
  bool m_blanket_unstaffed;
  int m_capacity;
  int m_capacity_staffed;
  QString m_children_proof;
  QStringList m_climbing_indoor_types;
  QStringList m_climbing_outdoor_types;
  QString m_climbing_rating_max;
  QString m_climbing_rating_median;
  QString m_climbing_rating_min;
  QStringList m_climbing_styles;
  QString m_custodianship;
  int m_elevation;
  int m_elevation_min;
  QStringList m_equipment_ratings;
  QString m_exposition_rating;
  bool m_gas_unstaffed;
  QStringList m_ground_types;
  bool m_heating_unstaffed;
  int m_height_max;
  int m_height_median;
  int m_height_min;
  int m_length;
  bool m_lift_access;
  QString m_maps_info;
  bool m_matress_unstaffed;
  QStringList m_orientations;
  QChar m_paragliding_rating;
  QString m_parking_fee;
  QString m_phone;
  QString m_phone_custodian;
  QStringList m_product_types;
  int m_prominence;
  QString m_public_transportation_rating;
  QStringList m_public_transportation_types;
  QString m_rain_proof;
  QStringList m_rock_types;
  int m_routes_quantity;
  int m_slackline_length_max;
  int m_slackline_length_min;
  QStringList m_slackline_types;
  int m_slope;
  QString m_snow_clearance_rating;
  QString m_url;
  QString m_waypoint_type;
  QStringList m_weather_station_types;

};

QDataStream & operator<<(QDataStream & out, const Waypoints & obj);
QDataStream & operator>>(QDataStream & in, Waypoints & obj);
// qRegisterMetaTypeStreamOperators<Waypoints>("Waypoints");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Waypoints & obj);
#endif

/**************************************************************************************************/

class WaypointsPtr
{
public:
  typedef Waypoints Class;

public:
  WaypointsPtr() : m_ptr() {}
  WaypointsPtr(const WaypointsPtr & other) : m_ptr(other.m_ptr) {}
  ~WaypointsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete WaypointsPtr of" << *m_ptr;
    // qInfo() << "--- Delete WaypointsPtr";
    // m_ptr.clear();
  }

  WaypointsPtr & operator=(const WaypointsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  WaypointsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  WaypointsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  WaypointsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  WaypointsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  WaypointsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  WaypointsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  WaypointsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const WaypointsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const WaypointsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const WaypointsPtr & obj);
#endif

/**************************************************************************************************/

class WaypointsCache : public QObject
{
  Q_OBJECT

public:
  typedef Waypoints * t_Key;
  typedef WaypointsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  WaypointsCache();
  ~WaypointsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class WaypointsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef WaypointsPtr Item;
  typedef QList<Item> ItemList;

public:
  WaypointsModel();
  WaypointsModel(const ItemList & items);
  ~WaypointsModel();

  // Fixme: use WaypointsSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACCESS_TIME,
    BEST_PERIODS,
    BLANKET_UNSTAFFED,
    CAPACITY,
    CAPACITY_STAFFED,
    CHILDREN_PROOF,
    CLIMBING_INDOOR_TYPES,
    CLIMBING_OUTDOOR_TYPES,
    CLIMBING_RATING_MAX,
    CLIMBING_RATING_MEDIAN,
    CLIMBING_RATING_MIN,
    CLIMBING_STYLES,
    CUSTODIANSHIP,
    ELEVATION,
    ELEVATION_MIN,
    EQUIPMENT_RATINGS,
    EXPOSITION_RATING,
    GAS_UNSTAFFED,
    GROUND_TYPES,
    HEATING_UNSTAFFED,
    HEIGHT_MAX,
    HEIGHT_MEDIAN,
    HEIGHT_MIN,
    LENGTH,
    LIFT_ACCESS,
    MAPS_INFO,
    MATRESS_UNSTAFFED,
    ORIENTATIONS,
    PARAGLIDING_RATING,
    PARKING_FEE,
    PHONE,
    PHONE_CUSTODIAN,
    PRODUCT_TYPES,
    PROMINENCE,
    PUBLIC_TRANSPORTATION_RATING,
    PUBLIC_TRANSPORTATION_TYPES,
    RAIN_PROOF,
    ROCK_TYPES,
    ROUTES_QUANTITY,
    SLACKLINE_LENGTH_MAX,
    SLACKLINE_LENGTH_MIN,
    SLACKLINE_TYPES,
    SLOPE,
    SNOW_CLEARANCE_RATING,
    URL,
    WAYPOINT_TYPE,
    WEATHER_STATION_TYPES
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class WaypointsLocales;
class WaypointsLocalesPtr;

/**************************************************************************************************/

class WaypointsLocalesSchema : public QcSchema
{
public:
  enum Fields {
    ID,
    ACCESS,
    ACCESS_PERIOD
  };
  static const int NUMBER_OF_FIELDS = 3;

public:
  static WaypointsLocalesSchema & instance()
  {
    static WaypointsLocalesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  WaypointsLocalesSchema(const WaypointsLocalesSchema &) = delete;
  WaypointsLocalesSchema(WaypointsLocalesSchema &&) = delete;
  WaypointsLocalesSchema & operator=(const WaypointsLocalesSchema &) = delete;
  WaypointsLocalesSchema & operator=(WaypointsLocalesSchema &&) = delete;

protected:
  WaypointsLocalesSchema();
  ~WaypointsLocalesSchema();
};

/**************************************************************************************************/

class WaypointsLocales : public QObject, public QcRow<WaypointsLocalesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QString access READ access WRITE set_access NOTIFY accessChanged)
  Q_PROPERTY(QString access_period READ access_period WRITE set_access_period NOTIFY access_periodChanged)

public:
  typedef WaypointsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class WaypointsLocalesPtr;

public:
  WaypointsLocales();
  WaypointsLocales(const WaypointsLocales & other);
  WaypointsLocales(const QJsonObject & json_object); // JSON deserializer
  WaypointsLocales(const QVariantHash & variant_hash);
  WaypointsLocales(const QVariantList & variants);
  WaypointsLocales(const QSqlRecord & record); // SQL deserializer
  WaypointsLocales(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~WaypointsLocales();

  WaypointsLocales & operator=(const WaypointsLocales & other);

  bool operator==(const WaypointsLocales & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QString & access() const { return m_access; }
  void set_access(const QString & value);

  const QString & access_period() const { return m_access_period; }
  void set_access_period(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_access_modified() const { return bit_status(Schema::Fields::ACCESS); }
  bool is_access_period_modified() const { return bit_status(Schema::Fields::ACCESS_PERIOD); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void accessChanged();
  void access_periodChanged();

private:
  int m_id;
  QString m_access;
  QString m_access_period;

};

QDataStream & operator<<(QDataStream & out, const WaypointsLocales & obj);
QDataStream & operator>>(QDataStream & in, WaypointsLocales & obj);
// qRegisterMetaTypeStreamOperators<WaypointsLocales>("WaypointsLocales");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const WaypointsLocales & obj);
#endif

/**************************************************************************************************/

class WaypointsLocalesPtr
{
public:
  typedef WaypointsLocales Class;

public:
  WaypointsLocalesPtr() : m_ptr() {}
  WaypointsLocalesPtr(const WaypointsLocalesPtr & other) : m_ptr(other.m_ptr) {}
  ~WaypointsLocalesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete WaypointsLocalesPtr of" << *m_ptr;
    // qInfo() << "--- Delete WaypointsLocalesPtr";
    // m_ptr.clear();
  }

  WaypointsLocalesPtr & operator=(const WaypointsLocalesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  WaypointsLocalesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  WaypointsLocalesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  WaypointsLocalesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  WaypointsLocalesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  WaypointsLocalesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  WaypointsLocalesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  WaypointsLocalesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const WaypointsLocalesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const WaypointsLocalesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const WaypointsLocalesPtr & obj);
#endif

/**************************************************************************************************/

class WaypointsLocalesCache : public QObject
{
  Q_OBJECT

public:
  typedef WaypointsLocales * t_Key;
  typedef WaypointsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  WaypointsLocalesCache();
  ~WaypointsLocalesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class WaypointsLocalesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef WaypointsLocalesPtr Item;
  typedef QList<Item> ItemList;

public:
  WaypointsLocalesModel();
  WaypointsLocalesModel(const ItemList & items);
  ~WaypointsLocalesModel();

  // Fixme: use WaypointsLocalesSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    ACCESS,
    ACCESS_PERIOD
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class Xreports;
class XreportsPtr;

/**************************************************************************************************/

class XreportsSchema : public QcSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACTIVITIES,
    ACTIVITY_RATE,
    AGE,
    AUTHOR_STATUS,
    AUTONOMY,
    AVALANCHE_LEVEL,
    AVALANCHE_SLOPE,
    DATE,
    DISABLE_COMMENTS,
    ELEVATION,
    EVENT_TYPE,
    GENDER,
    NB_IMPACTED,
    NB_OUTINGS,
    NB_PARTICIPANTS,
    PREVIOUS_INJURIES,
    RESCUE,
    SEVERITY
  };
  static const int NUMBER_OF_FIELDS = 19;

public:
  static XreportsSchema & instance()
  {
    static XreportsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  XreportsSchema(const XreportsSchema &) = delete;
  XreportsSchema(XreportsSchema &&) = delete;
  XreportsSchema & operator=(const XreportsSchema &) = delete;
  XreportsSchema & operator=(XreportsSchema &&) = delete;

protected:
  XreportsSchema();
  ~XreportsSchema();
};

/**************************************************************************************************/

class Xreports : public QObject, public QcRow<XreportsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QString activity_rate READ activity_rate WRITE set_activity_rate NOTIFY activity_rateChanged)
  Q_PROPERTY(int age READ age WRITE set_age NOTIFY ageChanged)
  Q_PROPERTY(QString author_status READ author_status WRITE set_author_status NOTIFY author_statusChanged)
  Q_PROPERTY(QString autonomy READ autonomy WRITE set_autonomy NOTIFY autonomyChanged)
  Q_PROPERTY(QString avalanche_level READ avalanche_level WRITE set_avalanche_level NOTIFY avalanche_levelChanged)
  Q_PROPERTY(QString avalanche_slope READ avalanche_slope WRITE set_avalanche_slope NOTIFY avalanche_slopeChanged)
  Q_PROPERTY(QDate date READ date WRITE set_date NOTIFY dateChanged)
  Q_PROPERTY(bool disable_comments READ disable_comments WRITE set_disable_comments NOTIFY disable_commentsChanged)
  Q_PROPERTY(int elevation READ elevation WRITE set_elevation NOTIFY elevationChanged)
  Q_PROPERTY(QStringList event_type READ event_type WRITE set_event_type NOTIFY event_typeChanged)
  Q_PROPERTY(QString gender READ gender WRITE set_gender NOTIFY genderChanged)
  Q_PROPERTY(int nb_impacted READ nb_impacted WRITE set_nb_impacted NOTIFY nb_impactedChanged)
  Q_PROPERTY(QString nb_outings READ nb_outings WRITE set_nb_outings NOTIFY nb_outingsChanged)
  Q_PROPERTY(int nb_participants READ nb_participants WRITE set_nb_participants NOTIFY nb_participantsChanged)
  Q_PROPERTY(QString previous_injuries READ previous_injuries WRITE set_previous_injuries NOTIFY previous_injuriesChanged)
  Q_PROPERTY(bool rescue READ rescue WRITE set_rescue NOTIFY rescueChanged)
  Q_PROPERTY(QString severity READ severity WRITE set_severity NOTIFY severityChanged)

public:
  typedef XreportsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class XreportsPtr;

public:
  Xreports();
  Xreports(const Xreports & other);
  Xreports(const QJsonObject & json_object); // JSON deserializer
  Xreports(const QVariantHash & variant_hash);
  Xreports(const QVariantList & variants);
  Xreports(const QSqlRecord & record); // SQL deserializer
  Xreports(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Xreports();

  Xreports & operator=(const Xreports & other);

  bool operator==(const Xreports & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QString & activity_rate() const { return m_activity_rate; }
  void set_activity_rate(const QString & value);

  int age() const { return m_age; }
  void set_age(int value);

  const QString & author_status() const { return m_author_status; }
  void set_author_status(const QString & value);

  const QString & autonomy() const { return m_autonomy; }
  void set_autonomy(const QString & value);

  const QString & avalanche_level() const { return m_avalanche_level; }
  void set_avalanche_level(const QString & value);

  const QString & avalanche_slope() const { return m_avalanche_slope; }
  void set_avalanche_slope(const QString & value);

  const QDate & date() const { return m_date; }
  void set_date(const QDate & value);

  bool disable_comments() const { return m_disable_comments; }
  void set_disable_comments(bool value);

  int elevation() const { return m_elevation; }
  void set_elevation(int value);

  const QStringList & event_type() const { return m_event_type; }
  void set_event_type(const QStringList & value);

  const QString & gender() const { return m_gender; }
  void set_gender(const QString & value);

  int nb_impacted() const { return m_nb_impacted; }
  void set_nb_impacted(int value);

  const QString & nb_outings() const { return m_nb_outings; }
  void set_nb_outings(const QString & value);

  int nb_participants() const { return m_nb_participants; }
  void set_nb_participants(int value);

  const QString & previous_injuries() const { return m_previous_injuries; }
  void set_previous_injuries(const QString & value);

  bool rescue() const { return m_rescue; }
  void set_rescue(bool value);

  const QString & severity() const { return m_severity; }
  void set_severity(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_activity_rate_modified() const { return bit_status(Schema::Fields::ACTIVITY_RATE); }
  bool is_age_modified() const { return bit_status(Schema::Fields::AGE); }
  bool is_author_status_modified() const { return bit_status(Schema::Fields::AUTHOR_STATUS); }
  bool is_autonomy_modified() const { return bit_status(Schema::Fields::AUTONOMY); }
  bool is_avalanche_level_modified() const { return bit_status(Schema::Fields::AVALANCHE_LEVEL); }
  bool is_avalanche_slope_modified() const { return bit_status(Schema::Fields::AVALANCHE_SLOPE); }
  bool is_date_modified() const { return bit_status(Schema::Fields::DATE); }
  bool is_disable_comments_modified() const { return bit_status(Schema::Fields::DISABLE_COMMENTS); }
  bool is_elevation_modified() const { return bit_status(Schema::Fields::ELEVATION); }
  bool is_event_type_modified() const { return bit_status(Schema::Fields::EVENT_TYPE); }
  bool is_gender_modified() const { return bit_status(Schema::Fields::GENDER); }
  bool is_nb_impacted_modified() const { return bit_status(Schema::Fields::NB_IMPACTED); }
  bool is_nb_outings_modified() const { return bit_status(Schema::Fields::NB_OUTINGS); }
  bool is_nb_participants_modified() const { return bit_status(Schema::Fields::NB_PARTICIPANTS); }
  bool is_previous_injuries_modified() const { return bit_status(Schema::Fields::PREVIOUS_INJURIES); }
  bool is_rescue_modified() const { return bit_status(Schema::Fields::RESCUE); }
  bool is_severity_modified() const { return bit_status(Schema::Fields::SEVERITY); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void activitiesChanged();
  void activity_rateChanged();
  void ageChanged();
  void author_statusChanged();
  void autonomyChanged();
  void avalanche_levelChanged();
  void avalanche_slopeChanged();
  void dateChanged();
  void disable_commentsChanged();
  void elevationChanged();
  void event_typeChanged();
  void genderChanged();
  void nb_impactedChanged();
  void nb_outingsChanged();
  void nb_participantsChanged();
  void previous_injuriesChanged();
  void rescueChanged();
  void severityChanged();

private:
  int m_document_id;
  QStringList m_activities;
  QString m_activity_rate;
  int m_age;
  QString m_author_status;
  QString m_autonomy;
  QString m_avalanche_level;
  QString m_avalanche_slope;
  QDate m_date;
  bool m_disable_comments;
  int m_elevation;
  QStringList m_event_type;
  QString m_gender;
  int m_nb_impacted;
  QString m_nb_outings;
  int m_nb_participants;
  QString m_previous_injuries;
  bool m_rescue;
  QString m_severity;

};

QDataStream & operator<<(QDataStream & out, const Xreports & obj);
QDataStream & operator>>(QDataStream & in, Xreports & obj);
// qRegisterMetaTypeStreamOperators<Xreports>("Xreports");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Xreports & obj);
#endif

/**************************************************************************************************/

class XreportsPtr
{
public:
  typedef Xreports Class;

public:
  XreportsPtr() : m_ptr() {}
  XreportsPtr(const XreportsPtr & other) : m_ptr(other.m_ptr) {}
  ~XreportsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete XreportsPtr of" << *m_ptr;
    // qInfo() << "--- Delete XreportsPtr";
    // m_ptr.clear();
  }

  XreportsPtr & operator=(const XreportsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  XreportsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  XreportsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  XreportsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  XreportsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  XreportsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  XreportsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  XreportsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const XreportsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const XreportsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const XreportsPtr & obj);
#endif

/**************************************************************************************************/

class XreportsCache : public QObject
{
  Q_OBJECT

public:
  typedef Xreports * t_Key;
  typedef XreportsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  XreportsCache();
  ~XreportsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class XreportsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef XreportsPtr Item;
  typedef QList<Item> ItemList;

public:
  XreportsModel();
  XreportsModel(const ItemList & items);
  ~XreportsModel();

  // Fixme: use XreportsSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACTIVITIES,
    ACTIVITY_RATE,
    AGE,
    AUTHOR_STATUS,
    AUTONOMY,
    AVALANCHE_LEVEL,
    AVALANCHE_SLOPE,
    DATE,
    DISABLE_COMMENTS,
    ELEVATION,
    EVENT_TYPE,
    GENDER,
    NB_IMPACTED,
    NB_OUTINGS,
    NB_PARTICIPANTS,
    PREVIOUS_INJURIES,
    RESCUE,
    SEVERITY
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class XreportsLocales;
class XreportsLocalesPtr;

/**************************************************************************************************/

class XreportsLocalesSchema : public QcSchema
{
public:
  enum Fields {
    ID,
    CONDITIONS,
    GROUP_MANAGEMENT,
    INCREASE_IMPACT,
    MODIFICATIONS,
    MOTIVATIONS,
    OTHER_COMMENTS,
    PLACE,
    REDUCE_IMPACT,
    RISK,
    ROUTE_STUDY,
    SAFETY,
    TIME_MANAGEMENT,
    TRAINING
  };
  static const int NUMBER_OF_FIELDS = 14;

public:
  static XreportsLocalesSchema & instance()
  {
    static XreportsLocalesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  XreportsLocalesSchema(const XreportsLocalesSchema &) = delete;
  XreportsLocalesSchema(XreportsLocalesSchema &&) = delete;
  XreportsLocalesSchema & operator=(const XreportsLocalesSchema &) = delete;
  XreportsLocalesSchema & operator=(XreportsLocalesSchema &&) = delete;

protected:
  XreportsLocalesSchema();
  ~XreportsLocalesSchema();
};

/**************************************************************************************************/

class XreportsLocales : public QObject, public QcRow<XreportsLocalesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QString conditions READ conditions WRITE set_conditions NOTIFY conditionsChanged)
  Q_PROPERTY(QString group_management READ group_management WRITE set_group_management NOTIFY group_managementChanged)
  Q_PROPERTY(QString increase_impact READ increase_impact WRITE set_increase_impact NOTIFY increase_impactChanged)
  Q_PROPERTY(QString modifications READ modifications WRITE set_modifications NOTIFY modificationsChanged)
  Q_PROPERTY(QString motivations READ motivations WRITE set_motivations NOTIFY motivationsChanged)
  Q_PROPERTY(QString other_comments READ other_comments WRITE set_other_comments NOTIFY other_commentsChanged)
  Q_PROPERTY(QString place READ place WRITE set_place NOTIFY placeChanged)
  Q_PROPERTY(QString reduce_impact READ reduce_impact WRITE set_reduce_impact NOTIFY reduce_impactChanged)
  Q_PROPERTY(QString risk READ risk WRITE set_risk NOTIFY riskChanged)
  Q_PROPERTY(QString route_study READ route_study WRITE set_route_study NOTIFY route_studyChanged)
  Q_PROPERTY(QString safety READ safety WRITE set_safety NOTIFY safetyChanged)
  Q_PROPERTY(QString time_management READ time_management WRITE set_time_management NOTIFY time_managementChanged)
  Q_PROPERTY(QString training READ training WRITE set_training NOTIFY trainingChanged)

public:
  typedef XreportsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class XreportsLocalesPtr;

public:
  XreportsLocales();
  XreportsLocales(const XreportsLocales & other);
  XreportsLocales(const QJsonObject & json_object); // JSON deserializer
  XreportsLocales(const QVariantHash & variant_hash);
  XreportsLocales(const QVariantList & variants);
  XreportsLocales(const QSqlRecord & record); // SQL deserializer
  XreportsLocales(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~XreportsLocales();

  XreportsLocales & operator=(const XreportsLocales & other);

  bool operator==(const XreportsLocales & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QString & conditions() const { return m_conditions; }
  void set_conditions(const QString & value);

  const QString & group_management() const { return m_group_management; }
  void set_group_management(const QString & value);

  const QString & increase_impact() const { return m_increase_impact; }
  void set_increase_impact(const QString & value);

  const QString & modifications() const { return m_modifications; }
  void set_modifications(const QString & value);

  const QString & motivations() const { return m_motivations; }
  void set_motivations(const QString & value);

  const QString & other_comments() const { return m_other_comments; }
  void set_other_comments(const QString & value);

  const QString & place() const { return m_place; }
  void set_place(const QString & value);

  const QString & reduce_impact() const { return m_reduce_impact; }
  void set_reduce_impact(const QString & value);

  const QString & risk() const { return m_risk; }
  void set_risk(const QString & value);

  const QString & route_study() const { return m_route_study; }
  void set_route_study(const QString & value);

  const QString & safety() const { return m_safety; }
  void set_safety(const QString & value);

  const QString & time_management() const { return m_time_management; }
  void set_time_management(const QString & value);

  const QString & training() const { return m_training; }
  void set_training(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_conditions_modified() const { return bit_status(Schema::Fields::CONDITIONS); }
  bool is_group_management_modified() const { return bit_status(Schema::Fields::GROUP_MANAGEMENT); }
  bool is_increase_impact_modified() const { return bit_status(Schema::Fields::INCREASE_IMPACT); }
  bool is_modifications_modified() const { return bit_status(Schema::Fields::MODIFICATIONS); }
  bool is_motivations_modified() const { return bit_status(Schema::Fields::MOTIVATIONS); }
  bool is_other_comments_modified() const { return bit_status(Schema::Fields::OTHER_COMMENTS); }
  bool is_place_modified() const { return bit_status(Schema::Fields::PLACE); }
  bool is_reduce_impact_modified() const { return bit_status(Schema::Fields::REDUCE_IMPACT); }
  bool is_risk_modified() const { return bit_status(Schema::Fields::RISK); }
  bool is_route_study_modified() const { return bit_status(Schema::Fields::ROUTE_STUDY); }
  bool is_safety_modified() const { return bit_status(Schema::Fields::SAFETY); }
  bool is_time_management_modified() const { return bit_status(Schema::Fields::TIME_MANAGEMENT); }
  bool is_training_modified() const { return bit_status(Schema::Fields::TRAINING); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void conditionsChanged();
  void group_managementChanged();
  void increase_impactChanged();
  void modificationsChanged();
  void motivationsChanged();
  void other_commentsChanged();
  void placeChanged();
  void reduce_impactChanged();
  void riskChanged();
  void route_studyChanged();
  void safetyChanged();
  void time_managementChanged();
  void trainingChanged();

private:
  int m_id;
  QString m_conditions;
  QString m_group_management;
  QString m_increase_impact;
  QString m_modifications;
  QString m_motivations;
  QString m_other_comments;
  QString m_place;
  QString m_reduce_impact;
  QString m_risk;
  QString m_route_study;
  QString m_safety;
  QString m_time_management;
  QString m_training;

};

QDataStream & operator<<(QDataStream & out, const XreportsLocales & obj);
QDataStream & operator>>(QDataStream & in, XreportsLocales & obj);
// qRegisterMetaTypeStreamOperators<XreportsLocales>("XreportsLocales");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const XreportsLocales & obj);
#endif

/**************************************************************************************************/

class XreportsLocalesPtr
{
public:
  typedef XreportsLocales Class;

public:
  XreportsLocalesPtr() : m_ptr() {}
  XreportsLocalesPtr(const XreportsLocalesPtr & other) : m_ptr(other.m_ptr) {}
  ~XreportsLocalesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qInfo() << "--- Delete XreportsLocalesPtr of" << *m_ptr;
    // qInfo() << "--- Delete XreportsLocalesPtr";
    // m_ptr.clear();
  }

  XreportsLocalesPtr & operator=(const XreportsLocalesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QcRowTraits ctor
  XreportsLocalesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  XreportsLocalesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  XreportsLocalesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  XreportsLocalesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  XreportsLocalesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  XreportsLocalesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  XreportsLocalesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const XreportsLocalesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const XreportsLocalesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const XreportsLocalesPtr & obj);
#endif

/**************************************************************************************************/

class XreportsLocalesCache : public QObject
{
  Q_OBJECT

public:
  typedef XreportsLocales * t_Key;
  typedef XreportsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  XreportsLocalesCache();
  ~XreportsLocalesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class XreportsLocalesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef XreportsLocalesPtr Item;
  typedef QList<Item> ItemList;

public:
  XreportsLocalesModel();
  XreportsLocalesModel(const ItemList & items);
  ~XreportsLocalesModel();

  // Fixme: use XreportsLocalesSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    CONDITIONS,
    GROUP_MANAGEMENT,
    INCREASE_IMPACT,
    MODIFICATIONS,
    MOTIVATIONS,
    OTHER_COMMENTS,
    PLACE,
    REDUCE_IMPACT,
    RISK,
    ROUTE_STUDY,
    SAFETY,
    TIME_MANAGEMENT,
    TRAINING
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class CamptocampDatabaseSchema : public QcDatabaseSchema
{
public:
  CamptocampDatabaseSchema(QcDatabase & database);
  CamptocampDatabaseSchema(const CamptocampDatabaseSchema & other) = delete;
  ~CamptocampDatabaseSchema();

  CamptocampDatabaseSchema & operator=(const CamptocampDatabaseSchema & other) = delete;

  QcDatabaseTable & area_associations() { return *m_area_associations; }
  QcDatabaseTable & areas() { return *m_areas; }
  QcDatabaseTable & articles() { return *m_articles; }
  QcDatabaseTable & associations() { return *m_associations; }
  QcDatabaseTable & books() { return *m_books; }
  QcDatabaseTable & documents() { return *m_documents; }
  QcDatabaseTable & documents_geometries() { return *m_documents_geometries; }
  QcDatabaseTable & documents_locales() { return *m_documents_locales; }
  QcDatabaseTable & documents_topics() { return *m_documents_topics; }
  QcDatabaseTable & documents_versions() { return *m_documents_versions; }
  QcDatabaseTable & images() { return *m_images; }
  QcDatabaseTable & map_associations() { return *m_map_associations; }
  QcDatabaseTable & maps() { return *m_maps; }
  QcDatabaseTable & outings() { return *m_outings; }
  QcDatabaseTable & outings_locales() { return *m_outings_locales; }
  QcDatabaseTable & routes() { return *m_routes; }
  QcDatabaseTable & routes_locales() { return *m_routes_locales; }
  QcDatabaseTable & user() { return *m_user; }
  QcDatabaseTable & user_profiles() { return *m_user_profiles; }
  QcDatabaseTable & waypoints() { return *m_waypoints; }
  QcDatabaseTable & waypoints_locales() { return *m_waypoints_locales; }
  QcDatabaseTable & xreports() { return *m_xreports; }
  QcDatabaseTable & xreports_locales() { return *m_xreports_locales; }

private:
  template<class T> void register_row(typename T::Ptr & row);

private:
  QcDatabaseTable * m_area_associations;
  QcDatabaseTable * m_areas;
  QcDatabaseTable * m_articles;
  QcDatabaseTable * m_associations;
  QcDatabaseTable * m_books;
  QcDatabaseTable * m_documents;
  QcDatabaseTable * m_documents_geometries;
  QcDatabaseTable * m_documents_locales;
  QcDatabaseTable * m_documents_topics;
  QcDatabaseTable * m_documents_versions;
  QcDatabaseTable * m_images;
  QcDatabaseTable * m_map_associations;
  QcDatabaseTable * m_maps;
  QcDatabaseTable * m_outings;
  QcDatabaseTable * m_outings_locales;
  QcDatabaseTable * m_routes;
  QcDatabaseTable * m_routes_locales;
  QcDatabaseTable * m_user;
  QcDatabaseTable * m_user_profiles;
  QcDatabaseTable * m_waypoints;
  QcDatabaseTable * m_waypoints_locales;
  QcDatabaseTable * m_xreports;
  QcDatabaseTable * m_xreports_locales;
  AreaAssociationsCache m_area_associations_cache;
  AreasCache m_areas_cache;
  ArticlesCache m_articles_cache;
  AssociationsCache m_associations_cache;
  BooksCache m_books_cache;
  DocumentsCache m_documents_cache;
  DocumentsGeometriesCache m_documents_geometries_cache;
  DocumentsLocalesCache m_documents_locales_cache;
  DocumentsTopicsCache m_documents_topics_cache;
  DocumentsVersionsCache m_documents_versions_cache;
  ImagesCache m_images_cache;
  MapAssociationsCache m_map_associations_cache;
  MapsCache m_maps_cache;
  OutingsCache m_outings_cache;
  OutingsLocalesCache m_outings_locales_cache;
  RoutesCache m_routes_cache;
  RoutesLocalesCache m_routes_locales_cache;
  UserCache m_user_cache;
  UserProfilesCache m_user_profiles_cache;
  WaypointsCache m_waypoints_cache;
  WaypointsLocalesCache m_waypoints_locales_cache;
  XreportsCache m_xreports_cache;
  XreportsLocalesCache m_xreports_locales_cache;
};

/**************************************************************************************************/
#endif /* __CAMPTOCAMP_SCHEMA_H__ */

/***************************************************************************************************
 *
 * End
 *
 **************************************************************************************************/