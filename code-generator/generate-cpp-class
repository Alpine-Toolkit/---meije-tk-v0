#! /usr/bin/env python3
# -*- Python -*-

####################################################################################################
#
# $QTCARTO_BEGIN_LICENSE:GPL3$
#
# Copyright (C) 2016 Fabrice Salvaire
# Contact: http://www.fabrice-salvaire.fr
#
# This file is part of the QtCarto library.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# $QTCARTO_END_LICENSE$
#
####################################################################################################

####################################################################################################

import argparse
import sys

from CppCodeGenerator import (Variable,
                              Header, ClassDefinition,
                              Source, ClassImplementation)

from GeneratorSettings import generator_settings

####################################################################################################
#
# Options
#

argument_parser = argparse.ArgumentParser(description='Generate CPP Class',
                                          formatter_class=argparse.ArgumentDefaultsHelpFormatter)

argument_parser.add_argument('--property', action='store_true')
argument_parser.add_argument('--inline-setter', action='store_true')
argument_parser.add_argument('--inline-getter', action='store_true')

argument_parser.add_argument('class_definition_path', metavar='class_def_file',
                             help='class_definition_path')

argument_parser.add_argument('class_file_name', metavar='class_file_name',
                             help='class_definition_path')

args = argument_parser.parse_args()

####################################################################################################

with open(args.class_definition_path) as f:
    class_definition = f.readlines()

class_line = class_definition[0]
if ':' in class_line:
    class_name, parent_class = [x.strip() for x in class_line.split(':')]
    if not parent_class:
        parent_class = None
else:
    class_name = class_line
    parent_class = None

members = []
for line in class_definition[1:]:
    line = line.strip()
    if line.endswith(';'):
        line = line[:-1]
    l = line.rfind(' ')
    type_ = line[:l].strip()
    name = line[l:].strip()
    if name.startswith('m_'):
        name = name[2:]
    member = Variable(name, type_)
    members.append(member)

####################################################################################################

header = Header(class_name, generator_settings)
header.cpp_mode()
header.header()
header.include('QObject')
header.include('...')
header.include('...', local=True)
header.new_line()
header.rule()
header.new_line()
header.comment('QC_BEGIN_NAMESPACE')
header.new_line()

class_definition = ClassDefinition(class_name.title(), parent_class, members, generator_settings)
class_definition.begin()
if args.property:
    for member in members:
        class_definition.property(member)
class_definition.public()
class_definition.ctor()
class_definition.dtor()
class_definition.new_line()
class_definition.copy_operator()
for member in members:
    class_definition.new_line()
    if args.inline_getter:
        class_definition.inline_getter(member)
    else:
        class_definition.getter(member)
    if args.inline_setter:
        class_definition.inline_setter(member)
    else:
        class_definition.setter(member)
if args.property:
    class_definition.signals()
    for member in members:
        class_definition.property_changed_signal(member)
class_definition.private()
# class_definition.append_members()
for member in members:
    class_definition.member(member.to_member())
class_definition.close()

header.append(class_definition)
header.new_line()
header.comment('QC_END_NAMESPACE')
header.footer()

# print(str(header))

with open(args.class_file_name + '.h-generated', 'w') as f:
    f.write(str(header))

####################################################################################################

source = Source(class_name, generator_settings)
source.header()
source.include(args.class_file_name, local=True)
source.new_line()
source.rule()
source.new_line()
source.comment('QC_BEGIN_NAMESPACE')
source.new_line()

class_implementation = class_definition.to_implementation()
class_implementation.ctor()
class_implementation.new_line()
class_implementation.copy_ctor()
class_implementation.new_line()
class_implementation.dtor()
class_implementation.new_line()
class_implementation.copy_operator_ctor()

for member in members:
    class_implementation.new_line()
    class_implementation.getter(member)
    class_implementation.new_line()
    class_implementation.setter(member)

# self.format('\n\n')
# for member in members:
#     self.format('.set_{name}(json_object[QStringLiteral(\'{name}\')].toString());\n'.format(class_name=class_name, **member))

source.append(class_implementation)
source.new_line()
source.comment('QC_END_NAMESPACE')
source.footer()

# print(str(source))

with open(args.class_file_name + '.cpp-generated', 'w') as f:
    f.write(str(source))
